=begin

  $Id: Tutorial.rd.ja,v 1.16 2005/09/24 14:58:21 ngoto Exp $

  Copyright (C) 2001-2003 KATAYAMA Toshiaki <k@bioruby.org>

  英語版翻訳: Naohisa Goto <ng@bioruby.org>
  英語版監訳: PjotrPrins

Wikiでご覧になっている方へ: この文書はBioRubyのCVSレポジトリにて管理
しています。Wikiで編集しても、別途CVSにも反映させないと変更内容が失わ
れてしまいます。連絡方法は((<URL:http://bioruby.org>)) をご覧ください。

= BioRuby の使い方

== はじめに

言うまでもないことですが、BioRubyを使用するにはRubyとBioRubyをインストール
する必要があります。インストール方法は((<README>))をご覧ください。
(EDITOR's NOTE: urlを示す必要がある。)
(EDITOR's NOTE: rdoc)

Ruby言語自体の入門については、http://www.ruby-lang.org/ や市販の単行本
を参照してください。

あなたのコンピュータにどのバージョンのRubyがインストールされているかを
チェックするには

    % ruby -v

とコマンドを入力してください。すると、たとえば

   ruby 1.8.2 (2005-04-11) [powerpc-linux]

のような感じでバージョンが表示されます。

== 塩基・アミノ酸配列を処理する (Bio::Sequence クラス)

Bio::Sequence クラスは、配列に対する様々な操作を行うことができます。
簡単な例として、短い塩基配列 atgcatgcaaaa を使って、相補配列への変換、
部分配列の切り出し、塩基組成の計算、アミノ酸への翻訳、分子量計算などを
行なってみます。アミノ酸への翻訳では、必要に応じて何塩基目から翻訳を開
始するかフレームを指定したり、codontable.rb で定義されているコドンテー
ブルの中から使用するものを指定したりする事ができます。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    seq = Bio::Sequence::NA.new("atgcatgcaaaa")
    
    puts seq                            # 元の配列
    puts seq.complement                 # 相補配列 (Sequence::NA オブジェクト)
    puts seq.subseq(3,8)                # 3 塩基目から 8 塩基目まで
    
    p seq.gc_percent                    # GC 塩基の割合 (bioruby 0.6以前: Float 0.7以降: Integer)
    p seq.composition                   # 全塩基組成 (Hash)
    
    puts seq.translate                  # 翻訳配列 (Sequence::AA オブジェクト)
    puts seq.translate(2)               # ２文字目から翻訳（普通は１から）
    puts seq.translate(1,11)            # 11番目のコドンテーブルを使用
                                        # (コドンテーブルの番号は http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi を参照。)
    
    p seq.translate.codes               # アミノ酸を３文字コードで表示 (Array)
    p seq.translate.names               # アミノ酸を名前で表示 (Array)
    p seq.translate.composition         # アミノ酸組成 (Hash)
    p seq.translate.molecular_weight    # 分子量を計算 (Float)
    
    puts seq.complement.translate       # 相補配列の翻訳

pやprintやputsは指定した内容を表示するためのRuby標準メソッドです。
Ruby標準装備のクラスやメソッドについては、
((<Rubyのリファレンスマニュアル|URL:http://www.ruby-lang.org/ja/man/>))
を参照してください。(Windows版Rubyならヘルプも使えるかもしれません。)
英語での表示になりますが、riコマンドも使えます。

  % ri p

(日本語でコマンドラインからリファレンスマニュアルを見たい場合は、
((<refe|URL:http://i.loveruby.net/ja/prog/refe.html>))
をインストールするのがお勧めです。)

塩基配列は Bio::Sequence::NA クラスの、アミノ酸配列は Bio::Sequence::AA
クラスのオブジェクトになります。それぞれ Bio::Sequence クラスを継承し
ているため、多くのメソッドは共通です。

Bio::Sequence クラスは Ruby の String クラスを継承しているので String
クラスが持つメソッドも使う事ができます。例えば部分配列を切り出すには
subseq(from,to) の他に、String の [] メソッドも使うことができます。
ただし、Ruby の文字列は 1 文字目を 0 番目として数える点には注意が必要です。
たとえば、

  s = 'abc'
  puts s[0..0]

  >a

Stringのメソッドを使う場合は、生物学で普通使用される1文字目を1番目として
数えた場所の数字からは 1 を引く必要があります。（subseq メソッドはこれを
内部でやっています。また、from, to のどちらかでも 0 以下の場合は nil を
返すようになっています。）

window_search(window_size, step_size) メソッドを使うと、配列に対してウィ
ンドウをずらしながらそれぞれの部分配列に対する処理を行うことができます。
Rubyの特長のひとつである「ブロック」によって、「それぞれに対する処理」を
簡潔かつ明瞭に書くことが可能です。以下の例では、's' という変数にそれぞれ
部分配列を代入しながらブロックを繰り返し実行することになります。

* 100 塩基ごとに（1塩基ずつずらしながら）平均 GC% を計算して表示する

    seq.window_search(100) do |s|
      puts s.gc_percent
    end

ブロックの中で受け取る部分配列も、元と同じ Bio::Sequence::NA または 
Bio::Sequence::AA クラスのオブジェクトなので、配列クラスの持つ全てのメ
ソッドを実行することができます。

また、２番目の引数に移動幅を指定することが出来るようになっているので、

* コドン単位でずらしながら 15 塩基を翻訳して表示する

    seq.window_search(15, 3) do |s|
      puts s.translate
    end

といったことができます。さらに移動幅に満たない右端の部分配列をメソッド
自体の返り値として戻すようになっているので、

* ゲノム配列を 10000bp ごとにブツ切りにして FASTA フォーマットに整形、
  このとき末端 1000bp はオーバーラップさせ、10000bp に満たない 3' 端は
  別途受け取って表示する

    i = 1
    remainder = seq.window_search(10000, 9000) do |s|
      puts s.to_fasta("segment #{i}", 60)
      i += 1
    end
    puts remainder.to_fasta("segment #{i}", 60)

のような事もわりと簡単にできます。

ウィンドウの幅と移動幅を同じにするとオーバーラップしないウィンドウサー
チができるので、

* コドン頻度を数える

    codon_usage = Hash.new(0)
    seq.window_search(3, 3) do |subseq|
      codon_usage[subseq] += 1
    end

* 10 残基ずつ分子量を計算

    seq.window_search(10, 10) do |subseq|
      puts subseq.molecular_weight
    end

といった応用も考えられます。

実際には Bio::Sequence::NA オブジェクトはファイルから読み込んだ文字列か
ら生成したり、データベースから取得したものを使ったりします。たとえば、

    #!/usr/bin/env ruby
    
    require 'bio'
    
    input_seq = ARGF.read       # 引数で与えられたファイルの全行を読み込む
    
    my_naseq = Bio::Sequence::NA.new(input_seq)
    my_aaseq = my_naseq.translate
    
    puts my_aaseq

このプログラムを na2aa.rb として、以下の塩基配列

      gtggcgatctttccgaaagcgatgactggagcgaagaaccaaagcagtgacatttgtctg
      atgccgcacgtaggcctgataagacgcggacagcgtcgcatcaggcatcttgtgcaaatg
      tcggatgcggcgtga

を書いたファイル my_naseq.txt を読み込んで翻訳すると

    % ./na2aa.rb my_naseq.txt
    VAIFPKAMTGAKNQSSDICLMPHVGLIRRGQRRIRHLVQMSDAA*

のようになります。ちなみに、このくらいの例なら短くすると１行で書けます。

    % ruby -r bio -e 'p Bio::Sequence::NA.new($<.read).translate' my_naseq.txt

しかし、いちいちファイルを作るのも面倒なので、次はデータベースから必要な
情報を取得してみます。


== GenBank のパース (Bio::GenBank クラス)

GenBank 形式のファイルを用意してください。(なければ、
ftp://ftp.ncbi.nih.gov/genbank/ から .seq ファイルをダウンロードすること。)

まずは、各エントリから ID と説明文、配列を取り出して FASTA 形式に変換して
みましょう。なお、これと同じような例はBioRubyのサンプルスクリプトにも入って
います。

Bio::GenBank::DELIMITER は GenBank クラスで定義されている定数で、
データベースごとに異なるエントリの区切り文字（たとえば GenBank の場合は //）
を覚えていなくても良いようになっています。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    while entry = gets(Bio::GenBank::DELIMITER)
      gb = Bio::GenBank.new(entry)      # GenBank オブジェクト
    
      print ">#{gb.accession} "         # ACCESSION 番号
      puts gb.definition                # DEFINITION 行
      puts gb.naseq                     # 塩基配列（Sequence::NA オブジェクト）
    end

しかし、これはGenBankファイルのデータ構造に依存しています。
ファイルからのデータ入力を扱うクラス Bio::FlatFile を使用することで、
以下のようにより汎用的に書くことができます。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ff = Bio::FlatFile.new(Bio::GenBank, ARGF)
    ff.each_entry do |gb|
      definition = "#{gb.accession} #{gb.definition}"
      puts gb.naseq.to_fasta(definition, 60)    
    end

形式の違うデータ、たとえばFASTAフォーマットのファイルを読み込むときでも、

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ff = Bio::FlatFile.new(Bio::FastaFormat, ARGF)
    ff.each_entry do |f|
      puts "definition : " + f.definition
      puts "nalen      : " + f.nalen.to_s
      puts "naseq      : " + f.naseq
    end

のように、似た書き方で済ませられます。

上の例では、Bio::FlatFile.new の最初の引数にデータベースファイルのフォー
マットを BioRuby のクラス名で指定しています。これについて詳しくは次の
セクションを参照してください。

さらに、各 Bio::DB クラスの open メソッドで同様のことができます。たとえば、

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ff = Bio::GenBank.open("gbvrl1.seq")
    ff.each_entry do |gb|
      definition = "#{gb.accession} #{gb.definition}"
      puts gb.naseq.to_fasta(definition, 60)    
    end

などと書くことができます。(ただし、この書き方はあまり使われていません。)

次に、GenBank の複雑な FEATURES の中をパースして、遺伝子ごとの塩基配列と
アミノ酸配列を取り出してみます。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ff = Bio::FlatFile.new(Bio::GenBank, ARGF)

    # GenBank の１エントリごとに
    ff.each_entry do |gb|

      # ACCESSION 番号と生物種名を表示
      puts "# #{gb.accession} - #{gb.organism}"
    
      gb.features.each do |feature|     # FEATURES の要素を一つずつ処理
        position = feature.position
        hash = feature.assoc            # レガシーだが簡単のためハッシュに直す

        # /translation= がなければスキップ
        next unless hash['translation']

        # 遺伝子名などの情報を集める
        gene_info = [
          hash['gene'], hash['product'], hash['note'], hash['function']
        ].compact.join(', ')

        # 塩基配列
        puts ">NA splicing('#{position}') : #{gene_info}"
        puts gb.naseq.splicing(position)

        # アミノ酸配列（塩基配列から翻訳）
        puts ">AA translated by splicing('#{position}').translate"
        puts gb.naseq.splicing(position).translate

        # アミノ酸配列（/translation= のもの）
        puts ">AA original translation"
        puts hash['translation']
      end
    end

* 注：上記のように assoc メソッドで Feature オブジェクトからハッシュを生成
  すると qualifier をキーとしてデータを取り出すことができるので便利ですが、
  キーが同一の複数の qualifier が 1 つの feature 中に存在する場合、情報が
  失われます（これを防ぐためにFeature#featureメソッドではデータを配列で
  持たせています）。

上の例で使用されている Bio::Sequence#splicing メソッドは、GenBank,EMBL,DDBJ
フォーマットのLocationの表記を元に、塩基配列から部分配列を切り出す強力な
メソッドです。

もし、データで使用しているコドンテーブルがデフォルト(universal)と違ったり、
最初のコドンが "atg" 以外だったり、セレノシステインが含まれていたり、
あるいは BioRuby にバグがあれば、上の例の最後の2行で表示されるアミノ酸配列
が異なる事になります。

この splicing メソッドの引数には GenBank の Feature で使われている形式の
文字列以外に Bio::Locations オブジェクトを渡すことも可能です。
Location文字列のフォーマットや Bio::Locations について詳しく知りたい場合は 
bio/location.rb を見てください。

* GenBank形式のデータの Feature で使われていたLocation文字列の例

    naseq.splicing('join(2035..2050,complement(1775..1818),13..345')

* あらかじめ Locations オブジェクトに変換してから渡してもよい

    locs = Bio::Locations.new('join((8298.8300)..10206,1..855)')
    naseq.splicing(locs)

ちなみに、アミノ酸配列 (Bio::Sequence::AA) についても splicing メソッド
を使用して部分配列を取り出すことが可能です。

* アミノ酸配列の部分配列を切り出す(たとえばシグナルペプチドとか)

    aaseq.splicing('21..119')


=== GenBank 以外のデータベース

BioRuby では、GenBank 以外のデータベースについても基本的なやり方は同じで、
データベースの１エントリを対応するデータベースのクラスに渡せば、パースさ
れた結果がオブジェクトになって返ってきます。

データベースのフラットファイルから１エントリずつ取り出してパースされた
オブジェクトを取り出すには、先にも出てきた Bio::FlatFile を使います。
Bio::FlatFile.new の引数にはデータベースに対応する BioRuby でのクラス
名 (Bio::GenBank や Bio::KEGG::GENES など) を指定します。

    ff = Bio::FlatFile.new(Bio::データベースクラス名, ARGF)

が、すばらしいことに、実は FlatFile クラスはデータベースの自動認識がで
きますので、

    ff = Bio::FlatFile.auto(ARGF)

を使うのが一番簡単です。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ff = Bio::FlatFile.auto(ARGF)
    ff.each_entry do |entry|
      p entry.entry_id          # エントリの ID
      p entry.definition        # エントリの説明文
      p entry.seq               # 配列データベースの場合
    end

パースされたオブジェクトから、エントリ中のそれぞれの部分を取り出すための
メソッドはデータベース毎に異なります。よくある項目については

  * entry_id メソッド → エントリの ID 番号が返る
  * definition メソッド → エントリの定義行が返る
  * reference メソッド → リファレンスオブジェクトが返る
  * organism メソッド → 生物種名
  * seq や naseq や aaseq メソッド → 対応する配列オブジェクトが返る

などのように共通化しようとしていますが、全てのメソッドが実装されているわ
けではありません（共通化の指針は bio/db.rb 参照）。また、細かい部分は各
データベースパーザ毎に異なるので、それぞれのドキュメントに従います。

原則として、メソッド名が複数形の場合は、オブジェクトが配列として返ります。
たとえば references メソッドを持つクラスは複数の Bio::Reference オブジェ
クトを Array にして返しますが、別のクラスでは単数形の reference メソッド
しかなく、１つの Bio::Reference オブジェクトだけを返す、といった感じです。


=== アライメント (Bio::Alignment クラス)

Bio::Alignmentクラス (bio/alignment.rb に記述されています) はRubyのHash
やArray、あるいは BioPerl の Bio::SimpleAlign に似た感じの、アライメントを
格納するコンテナクラスです。以下に簡単な使い方を示します。

  require 'bio'

  seqs = [ 'atgca', 'aagca', 'acgca', 'acgcg' ]
  seqs = seqs.collect{ |x| Bio::Sequence::NA.new(x) }

  # アライメントオブジェクトを作成
  a = Bio::Alignment.new(seqs)

  # コンセンサス配列を表示
  p a.consensus             # ==> "a?gc?"

  # IUPAC標準の曖昧な塩基を使用したコンセンサス配列を表示
  p a.consensus_iupac       # ==> "ahgcr"

  # 各配列について繰り返す
  a.each { |x| p x }
    # ==>
    #    "atgca"
    #    "aagca"
    #    "acgca"
    #    "acgcg"
  # 各サイトについて繰り返す
  a.each_site { |x| p x }
    # ==>
    #    ["a", "a", "a", "a"]
    #    ["t", "a", "c", "c"]
    #    ["g", "g", "g", "g"]
    #    ["c", "c", "c", "c"]
    #    ["a", "a", "a", "g"]

  # CLUSTAL W を使用してアライメントを行う。
  # clustalwコマンドがシステムにインストールされている必要がある。
  factory = Bio::ClustalW.new
  a2 = a.do_align(factory)


== FASTA による相同性検索を行う（Bio::Fasta クラス）

FASTA 形式の配列ファイル query.pep に対して、自分のマシン(ローカル)あるいは
インターネット上のサーバ(リモート)で FASTA による相同性検索を行う方法です。
ローカルの場合は SSEARCH なども同様に使うことができます。

=== ローカルの場合

FASTA がインストールされていることを確認してください。（コマンド名が
 fasta34 でパスが通ったディレクトリにインストールされていると仮定します。
無い場合は ftp://ftp.virginia.edu/pub/fasta/ からダウンロードおよび
インストールを行ってください。）検索対象とする FASTA 形式のデータ
ベースファイル target.pep と、FASTA 形式で問い合わせ配列がいくつか入った
ファイル query.pep を準備し、

    #!/usr/bin/env ruby
    
    require 'bio'
    
    # FASTA を実行する環境オブジェクトを作る（ssearch などでも良い）
    factory = Bio::Fasta.local('fasta34', ARGV.pop)
    
    # フラットファイルを読み込み、FastaFormat オブジェクトのリストにする
    ff = Bio::FlatFile.new(Bio::FastaFormat, ARGF)
    
    # １エントリずつの FastaFormat オブジェクトに対し
    ff.each do |entry|
      # '>' で始まるコメント行の内容を進行状況がわりに標準エラー出力に表示
      $stderr.puts "Searching ... " + entry.definition
   
      # FASTA による相同性検索を実行、結果は Fasta::Report オブジェクト
      report = factory.query(entry)
    
      # ヒットしたものそれぞれに対し
      report.each do |hit|
        # evalue が 0.0001 以下の場合
        if hit.evalue < 0.0001
          # その evalue と、名前、オーバーラップ領域を表示
          print "#{hit.query_id} : evalue #{hit.evalue}\t#{hit.target_id} at "
          p hit.lap_at
        end
      end
    end

というスクリプトを f_search.rb という名前で作ったとすると、

    % ./f_search.rb query.pep target.pep > f_search.out

のように実行すれば検索することができます。

ここで factory は繰り返し FASTA を実行するために、あらかじめ作っておく実
行環境です。上の例では Fasta オブジェクトの query メソッドを使って検索し
ていますが、逆に問い合わせ配列に対し

    seq = ">test seq\nYQVLEEIGRGSFGSVRKVIHIPTKKLLVRKDIKYGHMNSKE"
    seq.fasta(factory)

のように factory を渡して fasta メソッドを呼ぶ方法もあります。
(TRANSLATOR'S NOTE: この機能は将来無くなるかもしれない。)

FASTA コマンドにオプションを与えたい場合、３番目の引数に FASTA のコマン
ドラインオプションを書いて渡します。ktup 値だけはメソッドで指定します。
たとえば ktup 値を 1 にして、トップ 10 位以内のヒットを得る場合のオプショ
ンは、以下のようになります。

    factory = Bio::Fasta.local('fasta34', 'target.pep', '-b 10')
    factory.ktup = 1

Bio::Fasta#query メソッドなどの返り値は Bio::Fasta::Report オブジェクト
です。この Report オブジェクトから、様々なメソッドで FASTA の出力結果の
ほぼ全てを自由に取り出せるようになっています。たとえば、ヒットに関する
スコアなどの主な情報は、

    report.each do |hit|
      puts hit.evalue           # E-value
      puts hit.sw               # Smith-Waterman スコア (*)
      puts hit.identity         # % identity
      puts hit.overlap          # オーバーラップしている領域の長さ 
      puts hit.query_id         # 問い合わせ配列の ID
      puts hit.query_def        # 問い合わせ配列のコメント
      puts hit.query_len        # 問い合わせ配列の長さ
      puts hit.query_seq        # 問い合わせ配列
      puts hit.target_id        # ヒットした配列の ID
      puts hit.target_def       # ヒットした配列のコメント
      puts hit.target_len       # ヒットした配列の長さ
      puts hit.target_seq       # ヒットした配列
      puts hit.query_start      # 相同領域の問い合わせ配列での開始残基位置
      puts hit.query_end        # 相同領域の問い合わせ配列での終了残基位置
      puts hit.target_start     # 相同領域のターゲット配列での開始残基位置
      puts hit.target_end       # 相同領域のターゲット配列での終了残基位置
      puts hit.lap_at           # 上記４位置の数値の配列
    end

などのメソッドで呼び出せます。これらのメソッドの多くは後で説明する
Bio::Blast::Report クラスと共通にしてあります。上記以外のメソッドや
FASTA 特有の値を取り出すメソッドが必要な場合は、Bio::Fasta::Report
クラスのドキュメントを参照してください。

もし、パースする前の手を加えていない fasta コマンドの実行結果が必要な
場合には、

    report = factory.query(entry)
    puts factory.output

のように、query メソッドを実行した後で factory オブジェクトの output
メソッドを使ってください。


=== リモートの場合

今のところ GenomeNet (fasta.genome.jp) での検索のみサポートしています。
リモートの場合は使用可能な検索対象データベースが決まっていますが、それ以
外の点については Bio::Fasta.remote と Bio::Fasta.local は同じように使う
ことができます。

GenomeNet で使用可能な検索対象データベース：

  * アミノ酸配列データベース
    * nr-aa, genes, vgenes.pep, swissprot, swissprot-upd, pir, prf, pdbstr

  * 塩基配列データベース
    * nr-nt, genbank-nonst, gbnonst-upd, dbest, dbgss, htgs, dbsts,
      embl-nonst, embnonst-upd, genes-nt, genome, vgenes.nuc

まず、この中から検索したいデータベースを選択します。問い合わせ配列の種類
と検索するデータベースの種類によってプログラムは決まります。

  * 問い合わせ配列がアミノ酸のとき
    * 対象データベースがアミノ酸配列データベースの場合、program は 'fasta'
    * 対象データベースが核酸配列データベースの場合、program は 'tfasta'

  * 問い合わせ配列が核酸配列のとき
    * 対象データベースが核酸配列データベースの場合、program は 'fasta'
    * (対象データベースがアミノ酸配列データベースの場合は検索不能?)

プログラムとデータベースの組み合せが決まったら

    program = 'fasta'
    database = 'genes'
    
    factory = Bio::Fasta.remote(program, database)

としてファクトリーを作り、ローカルの場合と同じように factory.query など
のメソッドで検索を実行します。


== BLAST による相同性検索を行う（Bio::Blast クラス）

BLAST もローカルと GenomeNet (blast.genome.jp) での検索をサポートして
います。できるだけ Bio::Fasta と API を共通にしていますので、上記の例を 
Bio::Blast と書き換えただけでも大丈夫な場合が多いです。

たとえば、先の f_search.rb は

    # BLAST を実行する環境オブジェクトを作る
    factory = Bio::Blast.local('blastp', ARGV.pop) 

と変更するだけで同じように実行できます。

同様に、GenomeNet を使用してBLASTを行う場合には Bio::Blast.remote を使います。
この場合、programの指定内容が FASTA と異なります。

  * 問い合わせ配列がアミノ酸のとき
    * 対象データベースがアミノ酸配列データベースの場合、program は 'blastp'
    * 対象データベースが核酸配列データベースの場合、program は 'tblastn'

  * 問い合わせ配列が塩基配列のとき
    * 対象データベースがアミノ酸配列データベースの場合、program は 'blastx'
    * 対象データベースが塩基配列データベースの場合、program は 'blastn'
    * (問い合わせ・データベース共に6フレーム翻訳を行う場合は 'tblastx')

をそれぞれ指定します。

ところで、Bio::Blast は、Ruby用のXMLライブラリである XMLParser または
REXML が使用可能な場合は、BLASTの "-m 7" オプションによるXML出力を利用
します(XMLParser のほうが高速なので優先的に使用されます) 。
なお、Ruby 1.8.0以降では REXMLはRuby本体に標準添付されています。
もしXMLライブラリがインストールされていない場合は "-m 8" のタブ区切りの
出力形式を扱うようにしています。しかし、このフォーマットでは得られる
データが限られるので、"-m 7" の XML 形式の出力を使うことをお勧めします。
(Ruby 1.8.0以降を使用すれば、特別な外部ライブラリを別途インストール
しなくても大丈夫です。Ruby 1.6.X では XMLParser または REXMLを別途
インストールしてください。)

すでに見たように Bio::Fasta::Report と Bio::Blast::Report の Hit オブジェ
クトはいくつか共通のメソッドを持っています。BLAST 固有のメソッドで良く使
いそうなものには bit_score や midline などがあります。

    report.each do |hit|
      puts hit.bit_score        # bit スコア (*)
      puts hit.query_seq        # 問い合わせ配列
      puts hit.midline          # アライメントの midline 文字列 (*)
      puts hit.target_seq       # ヒットした配列
      
      puts hit.evalue           # E-value
      puts hit.identity         # % identity
      puts hit.overlap          # オーバーラップしている領域の長さ 
      puts hit.query_id         # 問い合わせ配列の ID
      puts hit.query_def        # 問い合わせ配列のコメント
      puts hit.query_len        # 問い合わせ配列の長さ
      puts hit.target_id        # ヒットした配列の ID
      puts hit.target_def       # ヒットした配列のコメント
      puts hit.target_len       # ヒットした配列の長さ
      puts hit.query_start      # 相同領域の問い合わせ配列での開始残基位置
      puts hit.query_end        # 相同領域の問い合わせ配列での終了残基位置
      puts hit.target_start     # 相同領域のターゲット配列での開始残基位置
      puts hit.target_end       # 相同領域のターゲット配列での終了残基位置
      puts hit.lap_at           # 上記４位置の数値の配列
    end

FASTAとのAPI共通化のためと簡便のため、スコアなどいくつかの情報は1番目の
Hsp (High-scoring segment pair) の値をHitで返すようにしています。

Bio::Blast::Report オブジェクトは、以下に示すような、BLASTの結果出力の
データ構造をそのまま反映した階層的なデータ構造を持っています。具体的には

  * Bio::Blast::Report オブジェクトの @iteratinos に
    * Bio::Blast::Report::Iteration オブジェクトの Array が入っており
      Bio::Blast::Report::Iteration オブジェクトの @hits に
      * Bio::Blast::Report::Hits オブジェクトの Array が入っており
        Bio::Blast::Report::Hits オブジェクトの @hsps に
        * Bio::Blast::Report::Hsp オブジェクトの Array が入っている

という階層構造になっており、それぞれが内部の値を取り出すためのメソッドを
持っています。これらのメソッドの詳細や、BLAST 実行の統計情報などの値が
必要な場合には、 bio/appl/blast/*.rb 内のドキュメントやテストコードを
参照してください。


=== 既存の BLAST 出力ファイルをパースする

BLAST を実行した結果ファイルがすでに保存してあって、これを解析したい場合
には（Bio::Blast オブジェクトを作らずに） Bio::Blast::Report オブジェク
トを作りたい、ということになります。これには Bio::Blast.reports メソッド
を使います。対応しているのは デフォルト出力フォーマット("-m 0") または
"-m 7" オプションの XML フォーマット出力です。

    #!/usr/bin/env ruby
    
    require 'bio'

    # BLAST出力を順にパースして Bio::Blast::Report オブジェクトを返す
    Bio::Blast.reports(ARGF) do |report|
      puts "Hits for " + report.query_def + " against " + report.db
      report.each do |hit|
        print hit.target_id, "\t", hit.evalue, "\n" if hit.evalue < 0.001
      end
    end

のようなスクリプト hits_under_0.001.rb を書いて、

   % ./hits_under_0.001.rb *.xml

などと実行すれば、引数に与えた BLAST の結果ファイル *.xml を順番に処理で
きます。

Blast のバージョンや OS などによって出力される XML の形式が異なる可能性
があり、時々 XML のパーザがうまく使えないことがあるようです。その場合は
Blast 2.2.5 以降のバージョンをインストールするか -D や -m などのオプショ
ンの組み合せを変えて試してみてください。


=== リモート検索サイトを追加するには

注: このセクションは上級ユーザ向けです。

Blast 検索は NCBI をはじめ様々なサイトでサービスされていますが、今のとこ
ろ BioRuby では GenomeNet 以外には対応していません。これらのサイトは、

  * CGI を呼び出す（コマンドラインオプションはそのサイト用に処理する）
  * -m 8 など BioRuby がパーザを持っている出力フォーマットで blast の
    出力を取り出す

ことさえできれば、query を受け取って検索結果を Bio::Blast::Report.new に
渡すようなメソッドを定義するだけで使えるようになります。具体的には、この
メソッドを「exec_サイト名」のような名前で Bio::Blast の private メソッド
として登録すると、４番目の引数に「サイト名」を指定して

    factory = Bio::Blast.remote(program, db, option, 'サイト名')

のように呼び出せるようになっています。完成したら BioRuby プロジェクトま
で送ってもらえれば取り込ませて頂きます。


== PubMed を引いて引用文献リストを作る (Bio::PubMed クラス)

次は、NCBI の文献データベース PubMed を検索して引用文献リストを作成する
例です。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ARGV.each do |id|
      entry = Bio::PubMed.query(id)     # PubMed を取得するクラスメソッド
      medline = Bio::MEDLINE.new(entry) # Bio::MEDLINE オブジェクト
      reference = medline.reference     # Bio::Reference オブジェクト
      puts reference.bibtex             # BibTeX フォーマットで出力
    end

このスクリプトを pmfetch.rb など好きな名前で保存し、

    % ./pmfetch.rb 11024183 10592278 10592173

など引用したい論文の PubMed ID (PMID) を引数に並べると NCBI にアクセスし
て MEDLINE フォーマットをパースし BibTeX フォーマットに変換して出力して
くれるはずです。

他に、キーワードで検索する機能もあります。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    # コマンドラインで与えたキーワードのリストを１つの文字列にする
    keywords = ARGV.join(' ')
    
    # PubMed をキーワードで検索
    entries = Bio::PubMed.search(keywords)
    
    entries.each do |entry|
      medline = Bio::MEDLINE.new(entry) # Bio::MEDLINE オブジェクト
      reference = medline.reference     # Bio::Reference オブジェクト
      puts reference.bibtex             # BibTeX フォーマットで出力
    end

このスクリプトを pmsearch.rb など好きな名前で保存し

    % ./pmsearch.rb genome bioinformatics

など検索したいキーワードを引数に並べて実行すると、PubMed をキーワード
検索してヒットした論文のリストを BibTeX フォーマットで出力します。

最近では、NCBI は E-Utils というウェブアプリケーションを使うことが
推奨されているので、今後は Bio::PubMed.esearch メソッドおよび
Bio::PubMed.efetch メソッドを使う方が良いでしょう。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    keywords = ARGV.join(' ')
    
    options = {
      'maxdate' => '2003/05/31',
      'retmax' => 1000,
    }
    
    entries = Bio::PubMed.esearch(keywords, options)
    
    Bio::PubMed.efetch(entries).each do |entry|
      medline = Bio::MEDLINE.new(entry)
      reference = medline.reference
      puts reference.bibtex
    end

このスクリプトでは、上記の pmsearch.rb とほぼ同じように動きます。さらに、
NCBI E-Utils を活用することにより、検索対象の日付や最大ヒット件数などを
指定できるようになっているので、より高機能です。オプションに与えられる
引数については ((<E-Utils のヘルプページ|URL:http://eutils.ncbi.nlm.nih.gov/entrez/query/static/eutils_help.html>)) を参照してください。

ちなみに、ここでは bibtex メソッドで BibTeX フォーマットに変換しています
が、後述のように bibitem メソッドも使える他、nature メソッドや nar など
いくつかの雑誌のフォーマットにも対応しています（強調やイタリックなど
文字の修飾はできないのでそのまま使用することはできませんが）。

=== BibTeX の使い方のメモ

上記の例で集めた BibTeX フォーマットのリストを TeX で使う方法を簡単にま
とめておきます。引用しそうな文献を

    % ./pmfetch.rb 10592173 >> genoinfo.bib
    % ./pmsearch.rb genome bioinformatics >> genoinfo.bib

などとして genoinfo.bib ファイルに集めて保存しておき、

    \documentclass{jarticle}
    \begin{document}
    \bibliographystyle{plain}
    ほにゃらら KEGG データベース~\cite{PMID:10592173}はふがほげである。
    \bibliography{genoinfo}
    \end{document}

というファイル hoge.tex を書いて、

    % platex hoge
    % bibtex hoge   # → genoinfo.bib の処理
    % platex hoge   # → 文献リストの作成
    % platex hoge   # → 文献番号

とすると無事 hoge.dvi ができあがります。
    
=== bibitem の使い方のメモ

文献用に別の .bib ファイルを作りたくない場合は Reference#bibitem メソッ
ドの出力を使います。上記の pmfetch.rb や pmsearch.rb の

    puts reference.bibtex

の行を

    puts reference.bibitem

に書き換えるなどして、出力結果を

    \documentclass{jarticle}
    \begin{document}
    ほにゃらら KEGG データベース~\cite{PMID:10592173}はふがほげである。

    \begin{thebibliography}{00}

    \bibitem{PMID:10592173}
    Kanehisa, M., Goto, S.
    KEGG: kyoto encyclopedia of genes and genomes.,
    {\em Nucleic Acids Res}, 28(1):27--30, 2000.

    \end{thebibliography}
    \end{document}

のように \begin{thebibliography} で囲みます。これを hoge.tex とすると

    % platex hoge   # → 文献リストの作成
    % platex hoge   # → 文献番号

と２回処理すればできあがりです。


= OBDA

OBDA (Open Bio Database Access) とは、Open Bioinformatics Foundation
によって制定された、配列データベースへの共通アクセス方法です。これは、
2002 年の1月と2月に Arizona と Cape Town にて開催された BioHackathon
において、BioPerl, BioJava, BioPython, BioRuby などの各プロジェクトの
メンバーが参加して作成されました。

* BioRegistry (Directory)
  * データベース毎に配列をどこにどのように取りに行くかを指定する仕組み

* BioFlat
  * フラットファイルの 2 分木または BDB を使ったインデックス作成

* BioFetch
  * HTTP 経由でデータベースからエントリを取得するサーバとクライアント

* BioSQL
  * MySQL や PostgreSQL などの関係データベースに配列データを格納する
    ための schema と、エントリを取り出すためのメソッド

詳細は ((<URL:http://obda.open-bio.org/>)) を参照してください。
それぞれの仕様書は cvs.open-bio.org の CVSレポジトリに置いてあります。
または、((<URL:http://cvs.open-bio.org/cgi-bin/viewcvs/viewcvs.cgi/obda-specs/?cvsroot=obf-common>)) から参照できます。


== BioRegistry

BioRegistryとは、設定ファイルによって各データベースのエントリ取得方法を
指定することにより、どんな方法を使っているかをほとんど意識せずデータを
取得することを可能とするための仕組みです。
設定ファイルの優先順位は

  * (メソッドのパラメータで)指定したファイル
  * ~/.bioinformatics/seqdatabase.ini
  * /etc/bioinformatics/seqdatabase.ini
  * http://www.open-bio.org/registry/seqdatabase.ini

最後の open-bio.org の設定は、ローカルな設定ファイルが見つからない場合に
だけ参照します。

BioRuby の現在の実装では、すべてのローカルな設定ファイルを読み込み、
同じ名前の設定が複数存在した場合は、最初に見つかった設定だけが使用されます。
これを利用すると、たとえば、システム管理者が /etc/bioinformatics/ に置いた
設定のうち個人的に変更したいものだけ ~/.bioinformatics/ で上書きすることが
できます。サンプルの seqdatabase.ini ファイルが bioruby のソースに含まれて
いますので参照してください。

設定ファイルの中身は stanza フォーマットと呼ばれる書式で記述します。

    [データベース名]
    protocol=プロトコル名
    location=サーバ名

このようなエントリを各データベースについて記述することになります。
データベース名は、自分が使用するためのラベルなので分かりやすいものを
つければ良く、実際のデータベースの名前と異なっていても構わないようです。
同じ名前のデータベースが複数あるときは最初に書かれているものから順に
接続を試すように仕様書では提案されていますが、今のところ BioRuby では
それには対応していません。

また、プロトコルの種類によっては location 以外にも（MySQL のユーザ名など）
追加のオプションを記述する必要があります。現在のところ、仕様書で規定され
ている protocol としては以下のものがあります。

  * index-flat
  * index-berkeleydb
  * biofetch
  * biosql
  * bsane-corba
  * xembl

今のところ BioRuby で使用可能なのは index-flat, index-berkleydb, biofetch
と biosql だけです。また、BioRegistryや各プロトコルの仕様は変更されること
がありますが、BioRubyはそれに追従できていないかもしれません。

BioRegistry を使うには、まず Bio::Registryオブジェクトを作成します。
すると、設定ファイルが読み込まれます。

    reg = Bio::Registry.new
    
    # 設定ファイルに書いたデータベース名でサーバへ接続
    serv = reg.get_database('genbank')
    
    # ID を指定してエントリを取得
    entry = serv.get_by_id('AA2CG')

ここで serv は設定ファイルの [genbank] の欄で指定した protocol プロトコ
ルに対応するサーバオブジェクトで、Bio::SQL や Bio::Fetch などのインスタ
ンスが返っているはずです（データベース名が見つからなかった場合は nil）。

あとは OBDA 共通のエントリ取得メソッド get_by_id を呼んだり、サーバオ
ブジェクト毎に固有のメソッドを呼ぶことになりますので、以下の BioFetch や
BioSQL の解説を参照してください。


== BioFlat

BioFlat はフラットファイルに対してインデックスを作成し、エントリを高速に
取り出す仕組みです。インデックスの種類は、RUbyの拡張ライブラリに依存しない
index-flat と Berkeley DB (bdb) を使った index-berkeleydb の2種類が存在
します。なお、index-berkeleydb を使用するには、BDB という Ruby の拡張
ライブラリを別途インストールする必要があります。インデックスの作成には
bioruby パッケージに付属する br_bioflat.rb コマンドを使って、

    % br_bioflat.rb --makeindex データベース名 [--format クラス名] ファイル名

のようにします。BioRubyはデータフォーマットの自動認識機能を搭載している
ので --format オプションは省略可能ですが、万一うまく認識しなかった場合は
BioRuby の各データベースのクラス名を指定してください。検索は、

    % bioflat データベース名 エントリID

とします。具体的に GenBank の gbbct*.seq ファイルにインデックスを作成し
て検索する場合、

    % bioflat --makeindex my_bctdb --format GenBank gbbct*.seq
    % bioflat my_bctdb A16STM262

のような感じになります。

Ruby の bdb 拡張モジュール(詳細は http://raa.ruby-lang.org/project/bdb/ 参照)
がインストールされている場合は Berkeley DB を利用してインデックスを作成する
ことができます。この場合、

    % bioflat --makeindex-bdb データベース名 [--format クラス名] ファイル名

のように "--makeindex" のかわりに "--makeindex-bdb" を指定します。


== BioFetch

BioFetch は CGI を経由してサーバからデータベースのエントリを取得する仕様
で、サーバが受け取る CGI のオプション名、エラーコードなどが決められてい
ます。クライアントは HTTP を使ってデータベース、ID、フォーマットなどを指
定し、エントリを取得します。

BioRuby プロジェクトでは GenomeNet の DBGET システムをバックエンドとした
BioFetch サーバを実装しており、bioruby.org で運用しています。このサーバの
ソースコードは BioRuby の sample/ ディレクトリに入っています。現在のところ
BioFetch サーバはこの bioruby.org のものと EBI の二か所しかありません。

BioFetch を使ってエントリを取得するには、いくつかの方法があります。

(1) ウェブブラウザから検索する方法（以下のページを開く）

      http://bioruby.org/cgi-bin/biofetch.rb

(2) BioRuby付属の br_biofetch.rb コマンドを用いる方法

      % br_biofetch.rb db_name entry_id

(3) スクリプトの中から Bio::Fetch クラスを直接使う方法

      serv = Bio::Fetch.new(server_url)
      entry = serv.fetch(db_name, entry_id)

(4) スクリプトの中で BioRegistry 経由で Bio::Fetch クラスを間接的に使う方法

      reg = Bio::Registry.new
      serv = reg.get_database('genbank')
      entry = serv.get_by_id('AA2CG')

もし(4) を使いたい場合は seqdatabase.ini で

    [genbank]
    protocol=biofetch
    location=http://bioruby.org/cgi-bin/biofetch.rb
    biodbname=genbank

などと指定しておく必要があります。

=== BioFetch と Bio::KEGG::GENES, Bio::AAindex1 を組み合わせた例

次のプログラムは、BioFetch を使って KEGG の GENES データベースから古細菌
Halobacterium のバクテリアロドプシン遺伝子 (VNG1467G) を取ってきて、同じ
ようにアミノ酸指標データベースである AAindex から取得したαヘリックスの
指標 (BURA740101) を使って、幅 15 残基のウィンドウサーチをする例です。

    #!/usr/bin/env ruby
    
    require 'bio'

    entry = Bio::Fetch.query('hal', 'VNG1467G')
    aaseq = Bio::KEGG::GENES.new(entry).aaseq
    
    entry = Bio::Fetch.query('aax1', 'BURA740101')
    helix = Bio::AAindex1.new(entry).index
    
    position = 1
    win_size = 15
    
    aaseq.window_search(win_size) do |subseq|
      score = subseq.total(helix)
      puts [ position, score ].join("\t")
      position += 1
    end

ここで使っているクラスメソッド Bio::Fetch.query は暗黙に bioruby.org の
BioFetch サーバを使う専用のショートカットです。（このサーバは内部的には
ゲノムネットからデータを取得しています。KEGG/GENES データベースの hal や 
AAindex データベース aax1 のエントリは、他の BioFetch サーバでは取得でき
ないこともあって、あえて query メソッドを使っています。）

== BioSQL

to be written...

== BioRuby のサンプルプログラムの使い方

BioRuby のパッケージには samples/ ディレクトリ以下にいくつかのサンプルプ
ログラムが含まれています。古いものも混じっていますし、量もとても十分とは
言えないので、実用的で面白いサンプルの提供は歓迎です。

to be written...

== さらなる情報

他のチュートリアル的なドキュメントとしては、BioRuby Wikiに置いてある
BioRuby in Anger があります。

= APPENDIX

= KEGG API

別ファイルの KEGG_API.rd.ja や

  * ((<URL:http://www.genome.jp/kegg/soap/>))

を参照してください。

== Using BioRuby with R

(編集中)

== Using BioPerl from Ruby

(...)

== 必要なライブラリのインストール

現在のところ、BioRubyの使用には追加の外部ライブラリや拡張モジュールは必要
ありません(Ruby 1.8.0以降の場合)。(ただし、XMLParseやBDBなど、いくつかの
拡張モジュールをインストールすることで、一部の機能がスピードアップしたり
機能が増える場合があります。)

とはいえ、将来的には必要になるかもしれませんので、BioRubyのウェブサイトや
付属文書をチェックしてみてください。

Rubyの拡張ライブラリをインストールするには、基本的にはその配布物に付属の
READMEなどの文章を注意深く読んで、そこに書いてある事を手動で行う必要が
あります。(将来的には、gems が標準になってより簡単になるかもしれません。)

=end

