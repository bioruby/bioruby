=begin

  $Id: Tutorial.rd.ja,v 1.17 2005/12/06 12:29:00 k Exp $

  Copyright (C) 2001-2003, 2005 KATAYAMA Toshiaki <k@bioruby.org>

= BioRuby の使い方

BioRuby は国産の高機能オブジェクト指向スクリプト言語 Ruby のための
オープンソースなバイオインフォマティクス用ライブラリです。

Ruby 言語は Perl 言語ゆずりの強力なテキスト処理と、
シンプルで分かりやすい文法、クリアなオブジェクト指向機能により、
広く使われるようになりました。Ruby について詳しくは、ウェブサイト
http://www.ruby-lang.org/ や市販の書籍等を参照してください。

== はじめに

BioRuby を使用するには Ruby と BioRuby をインストールする必要があります。

=== Ruby のインストール

Ruby は Mac OS X や最近の UNIX には通常インストールされています。
Windows の場合も１クリックインストーラや ActiveScriptRuby などが
用意されています。見つからない場合は

  http://jp.rubyist.net/magazine/?0002-FirstProgramming
  http://jp.rubyist.net/magazine/?FirstStepRuby

などを参照してインストールしましょう。

あなたのコンピュータにどのバージョンの Ruby がインストールされているかを
チェックするには

  % ruby -v

とコマンドを入力してください。すると、たとえば

  ruby 1.8.2 (2004-12-25) [powerpc-darwin7.7.0]

のような感じでバージョンが表示されます。バージョン 1.8.2 以降をお勧めします。

=== BioRuby のインストール

BioRuby のインストール方法は http://bioruby.org/archive/ から
最新版を取得して以下のように行います。詳しくは同梱されている
README ファイルを参照して頂きたいのですが、１日がかりの
BioPerl と比べて BioRuby のインストールはすぐに終わります。

  % wget http://bioruby.org/archive/bioruby-x.x.x.tar.gz
  % tar zxvf bioruby-x.x.x.tar.gz
  % cd bioruby-x.x.x
  % ruby install.rb config
  % ruby install.rb setup
  # ruby install.rb install

さらに、RubyGems が使える環境であれば

  % gems install bio

だけでインストールできます。

このあと README に書かれているように

  bioruby-x.x.x/etc/bioinformatics/seqdatabase.ini

というファイルをホームディレクトリの ~/.bioinformatics にコピーして
おくとよいでしょう。RubyGems の場合は

  /usr/local/lib/ruby/gems/1.8/gems/bio-x.x.x/

などにあるはずです。

  % mkdir ~/.bioinformatics
  % cp bioruby-x.x.x/etc/bioinformatics/seqdatabase.ini ~/.bioinformatics

また、Emacs エディタを使うひとは Ruby のソースに同梱されている
ruby-mode.el をインストールしておくとよいでしょう。

  % mkdir -p ~/lib/lisp/ruby
  % cp ruby-x.x.x/misc/ruby-mode.el ~/lib/lisp/ruby

などとしておいて、~/.emacs に以下の設定を書き足します。

  ; subdirs の設定
  (let ((default-directory "~/lib/lisp"))
    (normal-top-level-add-subdirs-to-load-path)

  ; ruby-mode の設定
  (autoload 'ruby-mode "ruby-mode" "Mode for editing ruby source files")
  (add-to-list 'auto-mode-alist '("\\.rb$" . rd-mode))
  (add-to-list 'interpeter-mode-alist '("ruby" . ruby-mode))

== BioRuby シェル

BioRuby バージョン 0.7 以降では、簡単な操作は BioRuby と共にインストールされる
bioruby コマンドで行うことができます。

  % bioruby

bioruby コマンドは Ruby についてくるインタラクティブシェル irb を
利用していますので、Ruby にできることは全て自由に実行することができます。

=== 塩基, アミノ酸の配列を作る

--- seq

seq コマンドを使って文字列から塩基配列やアミノ酸配列を作ることができます。
塩基とアミノ酸は ATGC の含量が 90% 以上かどうかで自動判定されます。
ここでは、できた塩基配列を dna という変数に代入します。

  bioruby> dna = seq("atgcatgcaaaa")

変数の中身を確認するには Ruby の puts メソッドを使います。

  bioruby> puts dna
  atgcatgcaaaa

手元にあるファイルから配列を得ることもできます。
GenBank, EMBL, UniProt, FAST など主要な配列フォーマットは自動判別されます
（拡張子などのファイル名ではなくエントリの中身で判定されます）。
以下は UniProt フォーマットのエントリをファイルから読み込んでいます。
この方法では、複数のエントリがある場合最初のエントリだけが読み込まれます。

  bioruby> cdc2 = seq("p04551.sp")
  bioruby> puts cdc2
  MENYQKVEKIGEGTYGVVYKARHKLSGRIVAMKKIRLEDESEGVPSTAIREISLLKEVNDENNRSN...(略)

データベース名とエントリ名が分かっていれば、インターネットを通じて
配列を自動的に取得することができます。

  bioruby> psaB = seq("genbank:AB044425")
  bioruby> puts psaB
  actgaccctgttcatattcgtcctattgctcacgcgatttgggatccgcactttggccaaccagca...(略)

どこのデータベースからどのような方法でエントリを取得するかは、BioPerl
などと共通の OBDA 設定ファイル ~/.bioinformatics/seqdatabase.ini
を用いてデータベースごとに指定することができます（後述）。

どの方法で取得した場合も、seq コマンドによって返される配列は、
バイオインフォマティクスでもっとも基礎となるデータである
DNA 配列やアミノ酸配列をあつかう Bio::Sequence クラスのオブジェクトで、
DNA 配列のための Bio::Sequence::NA クラスと
アミノ酸配列のための Bio::sequence::AA クラスのどちらかになります。

配列がどちらのクラスに属するかは

  bioruby> p cdc2.class
  Bio::Sequence::AA

  bioruby> p psaB.class
  Bio::Sequence::NA

のように判定できます。自動判定が間違っている場合などには to_naseq,
to_aaseq メソッドで変換できます。

  bioruby> cdc2new = cdc2.to_naseq
  bioruby> p cdc2new.class
  Bio::Sequence::NA

これらのクラスは Ruby の文字列クラスである String を継承していますので、
length で長さを調べたり、+ で足し合わせたり、* で繰り返したりなど、
Ruby の文字列に対して行える操作は全て塩基配列やアミノ酸配列に対しても可能です。
これはオブジェクト指向の強力な側面の一つです。

  bioruby> puts dna.length
  12

  bioruby> puts dna + dna
  atgcatgcaaaaatgcatgcaaaa

  bioruby> puts dna * 5
  atgcatgcaaaaatgcatgcaaaaatgcatgcaaaaatgcatgcaaaaatgcatgcaaaa

--- complement

塩基配列の相補鎖配列を得るには塩基配列の complement メソッドを呼びます。

  bioruby> puts dna.complement
  ttttgcatgcat

--- translate

塩基配列をアミノ酸配列に翻訳するには translate メソッドを使います。
翻訳されたアミノ酸配列を pep という変数に代入してみます。

  bioruby> pep = dna.translate
  bioruby> puts pep
  MHAK

フレームを変えて翻訳するには

  bioruby> puts dna.translate(2)
  CMQ
  bioruby> puts dna.translate(3)
  ACK

などとします。

--- molecular_weight

分子量は molecular_weight メソッドで表示されます。

  bioruby> puts dna.molecular_weight
  3718.66444

  bioruby> puts pep.molecular_weight
  485.605

--- seqstat(seq)

seqstat コマンドを使うと、組成などの情報も一度に表示されます。

  bioruby> seqstat(dna)

  * * * Sequence statistics * * *

  5'->3' sequence   : atgcatgcaaaa
  3'->5' sequence   : ttttgcatgcat
  Translation   1   : MHAK
  Translation   2   : CMQ
  Translation   3   : ACK
  Translation  -1   : FCMH
  Translation  -2   : FAC
  Translation  -3   : LHA
  Length            : 12 bp
  GC percent        : 33 %
  Composition       : a -  6 ( 50.00 %)
                      c -  2 ( 16.67 %)
                      g -  2 ( 16.67 %)
                      t -  2 ( 16.67 %)
  Codon usage       :

   *---------------------------------------------*
   |       |              2nd              |     |
   |  1st  |-------------------------------| 3rd |
   |       |  U    |  C    |  A    |  G    |     |
   |-------+-------+-------+-------+-------+-----|
   | U   U |F  0.0%|S  0.0%|Y  0.0%|C  0.0%|  u  |
   | U   U |F  0.0%|S  0.0%|Y  0.0%|C  0.0%|  c  |
   | U   U |L  0.0%|S  0.0%|*  0.0%|*  0.0%|  a  |
   |  UUU  |L  0.0%|S  0.0%|*  0.0%|W  0.0%|  g  |
   |-------+-------+-------+-------+-------+-----|
   |  CCCC |L  0.0%|P  0.0%|H 25.0%|R  0.0%|  u  |
   | C     |L  0.0%|P  0.0%|H  0.0%|R  0.0%|  c  |
   | C     |L  0.0%|P  0.0%|Q  0.0%|R  0.0%|  a  |
   |  CCCC |L  0.0%|P  0.0%|Q  0.0%|R  0.0%|  g  |
   |-------+-------+-------+-------+-------+-----|
   |   A   |I  0.0%|T  0.0%|N  0.0%|S  0.0%|  u  |
   |  A A  |I  0.0%|T  0.0%|N  0.0%|S  0.0%|  c  |
   | AAAAA |I  0.0%|T  0.0%|K 25.0%|R  0.0%|  a  |
   | A   A |M 25.0%|T  0.0%|K  0.0%|R  0.0%|  g  |
   |-------+-------+-------+-------+-------+-----|
   |  GGGG |V  0.0%|A  0.0%|D  0.0%|G  0.0%|  u  |
   | G     |V  0.0%|A  0.0%|D  0.0%|G  0.0%|  c  |
   | G GGG |V  0.0%|A 25.0%|E  0.0%|G  0.0%|  a  |
   |  GG G |V  0.0%|A  0.0%|E  0.0%|G  0.0%|  g  |
   *---------------------------------------------*

  Molecular weight  : 3718.66444
  Protein weight    : 485.605
  //


アミノ酸配列の場合は以下のようになります。

  bioruby> seqstat(pep)

  * * * Sequence statistics * * *

  N->C sequence     : MHAK
  Length            : 4 aa
  Composition       : A Ala - 1 ( 25.00 %) alanine
                      H His - 1 ( 25.00 %) histidine
                      K Lys - 1 ( 25.00 %) lysine
                      M Met - 1 ( 25.00 %) methionine
  Protein weight    : 485.605
  //

--- composition

ここで表示される組成は composition メソッドで得ることができます。
結果が文字列ではなく Hash で返されるので、
puts の代わりに p コマンドを使って表示すると良いでしょう。

  bioruby> p dna.composition
  {"a"=>6, "c"=>2, "g"=>2, "t"=>2}

他にも塩基配列、アミノ酸配列に対して行える操作は色々とあります。

--- subseq(from, to)

部分配列の取り出し

  bioruby> puts dna.subseq(1, 3)
  atg

--- window_search(len, step)

部分配列毎の繰り返し

  bioruby> dna.window_search(3, 3) do |codon|
  bioruby+   puts "#{codon}\t#{codon.translate}"
  bioruby+ end
  atg     M
  cat     H
  gca     A
  aaa     K

ゲノム配列を 11000bp ごとにブツ切りにして FASTA フォーマットに整形。このとき末端 1000bp をオーバーラップさせ、10000bp に満たない 3' 端は 別途受け取って表示します。

  bioruby> i = 1
  bioruby> remainder = seq.window_search(11000, 10000) do |subseq|
  bioruby>   puts subseq.to_fasta("segment #{i*10000}", 60)
  bioruby>   i += 1
  bioruby> end
  bioruby> puts remainder.to_fasta("segment #{i}", 60)

--- splicing(position)

塩基配列の GenBank 等の position 文字列による切り出し

  bioruby> puts dna
  atgcatgcaaaa
  bioruby> puts dna.splicing("join(1..3,7..9)")
  atggca

--- randomize

ランダム配列の生成

  bioruby> puts dna.randomize
  agcaatagatac

--- to_re

正規表現への変換

  bioruby> ambiguous = seq("atgcyatgcatgcatgc")

  bioruby> p ambiguous.to_re
  /atgc[tc]atgcatgcatgc/

  bioruby> puts ambiguous.to_re
  (?-mix:atgc[tc]atgcatgcatgc)

seq メソッドは ATGC の含有量が 90% 以下だとアミノ酸配列とみなすので、
ambiguous な文字が多く含まれる配列の場合は明示的に Bio::Sequence::NA
オブジェクトを作る必要があります。

  bioruby> s = Bio::Sequence::NA.new("atgcurywskmbvhdn")
  bioruby> p s.to_re
  /augcu[ag][uc][au][gc][ug][ac][ugc][agc][auc][aug][augc]/
  bioruby> puts s.to_re
  (?-mix:augcu[ag][uc][au][gc][ug][ac][ugc][agc][auc][aug][augc])

--- names

塩基名、アミノ酸名での表示

  bioruby> p dna.names
  ["adenine", "thymine", "guanine", "cytosine", "adenine", "thymine",
  "guanine", "cytosine", "adenine", "adenine", "adenine", "adenine"]

  bioruby> p pep.names
  ["methionine", "histidine", "alanine", "lysine"]

--- codes

アミノ酸配列の 3 文字コードでの表示

  bioruby> p pep.codes
  ["Met", "His", "Ala", "Lys"]

--- gc_percent

塩基配列の GC 含量の表示

  bioruby> puts dna.gc_percent
  33

--- to_fasta

FASTA フォーマットに変換するには to_fasta メソッドを使います。

  bioruby> puts dna.to_fasta("dna sequence")
  >dna sequence
  aaccggttacgt


=== 塩基やアミノ酸のコード、コドン表をあつかう

アミノ酸、塩基、コドンテーブルを得るための aminoacids, nucleicacids,
codontables, codontable コマンドを紹介します。
 
--- aminoacids

アミノ酸の一覧

  bioruby> aminoacids
  ?       Pyl     pyrrolysine
  A       Ala     alanine
  B       Asx     asparagine/aspartic acid
  C       Cys     cysteine
  D       Asp     aspartic acid
  E       Glu     glutamic acid
  F       Phe     phenylalanine
  G       Gly     glycine
  H       His     histidine
  I       Ile     isoleucine
  K       Lys     lysine
  L       Leu     leucine
  M       Met     methionine
  N       Asn     asparagine
  P       Pro     proline
  Q       Gln     glutamine
  R       Arg     arginine
  S       Ser     serine
  T       Thr     threonine
  U       Sec     selenocysteine
  V       Val     valine
  W       Trp     tryptophan
  Y       Tyr     tyrosine
  Z       Glx     glutamine/glutamic acid

  bioruby> aa = aminoacids
  bioruby> puts aa["G"]
  Gly
  bioruby> puts aa["Gly"]
  glycine

--- nucleicacids

  bioruby> nucleicacids
  a       a       Adenine
  t       t       Thymine
  g       g       Guanine
  c       c       Cytosine
  u       u       Uracil
  r       [ag]    puRine
  y       [tc]    pYrimidine
  w       [at]    Weak
  s       [gc]    Strong
  k       [tg]    Keto
  m       [ac]    aroMatic
  b       [tgc]   not A
  v       [agc]   not T
  h       [atc]   not G
  d       [atg]   not C
  n       [atgc]  

  bioruby> na = nucleicacids
  bioruby> puts na["r"]
  [ag]

--- codontables

コドンテーブルの一覧は codontables コマンドで表示できます。

  bioruby> codontables
  1       Standard (Eukaryote)
  2       Vertebrate Mitochondrial
  3       Yeast Mitochondorial
  4       Mold, Protozoan, Coelenterate Mitochondrial and Mycoplasma/Spiroplasma
  5       Invertebrate Mitochondrial
  6       Ciliate Macronuclear and Dasycladacean
  9       Echinoderm Mitochondrial
  10      Euplotid Nuclear
  11      Bacteria
  12      Alternative Yeast Nuclear
  13      Ascidian Mitochondrial
  14      Flatworm Mitochondrial
  15      Blepharisma Macronuclear
  16      Chlorophycean Mitochondrial
  21      Trematode Mitochondrial
  22      Scenedesmus obliquus mitochondrial
  23      Thraustochytrium Mitochondrial

--- codontable

コドン表の自体は codontable コマンドで表示できます。

  bioruby> codontable(11)

   = Codon table 11 : Bacteria

     hydrophilic: H K R (basic), S T Y Q N S (polar), D E (acidic)
     hydrophobic: F L I M V P A C W G (nonpolar)

   *---------------------------------------------*
   |       |              2nd              |     |
   |  1st  |-------------------------------| 3rd |
   |       |  U    |  C    |  A    |  G    |     |
   |-------+-------+-------+-------+-------+-----|
   | U   U | Phe F | Ser S | Tyr Y | Cys C |  u  |
   | U   U | Phe F | Ser S | Tyr Y | Cys C |  c  |
   | U   U | Leu L | Ser S | STOP  | STOP  |  a  |
   |  UUU  | Leu L | Ser S | STOP  | Trp W |  g  |
   |-------+-------+-------+-------+-------+-----|
   |  CCCC | Leu L | Pro P | His H | Arg R |  u  |
   | C     | Leu L | Pro P | His H | Arg R |  c  |
   | C     | Leu L | Pro P | Gln Q | Arg R |  a  |
   |  CCCC | Leu L | Pro P | Gln Q | Arg R |  g  |
   |-------+-------+-------+-------+-------+-----|
   |   A   | Ile I | Thr T | Asn N | Ser S |  u  |
   |  A A  | Ile I | Thr T | Asn N | Ser S |  c  |
   | AAAAA | Ile I | Thr T | Lys K | Arg R |  a  |
   | A   A | Met M | Thr T | Lys K | Arg R |  g  |
   |-------+-------+-------+-------+-------+-----|
   |  GGGG | Val V | Ala A | Asp D | Gly G |  u  |
   | G     | Val V | Ala A | Asp D | Gly G |  c  |
   | G GGG | Val V | Ala A | Glu E | Gly G |  a  |
   |  GG G | Val V | Ala A | Glu E | Gly G |  g  |
   *---------------------------------------------*


codontable コマンドの結果を変数に代入するとコドンの変換に使うことができます。

  bioruby> ct = codontable(2)
  bioruby> p ct["atg"]
  "M"

コドン表の定義の説明

  bioruby> puts ct.definition
  Vertebrate Mitochondrial

開始コドン一覧

  bioruby> p ct.start
  ["att", "atc", "ata", "atg", "gtg"]

終止コドン一覧

  bioruby> p ct.stop
  ["taa", "tag", "aga", "agg"]

アミノ酸からコードするコドンを調べる

  bioruby> p ct.revtrans("V")
  ["gtc", "gtg", "gtt", "gta"]


=== フラットファイルのエントリ

データベースのエントリと、フラットファイルそのものを扱う方法を紹介します。
GenBank のファージのエントリが含まれるファイル gbphg.seq はファイルサイズが
小さいので例として使ってみます。

  % wget http://ftp.hgc.jp/pub/mirror/ncbi/genbank/gbphg.seq.gz
  % gunzip gbphg.seq.gz

--- ent

seq コマンドは配列を取得しましたが、配列だけでなくエントリ全体を取得するには
ent コマンドを使います。

  bioruby> entry = ent("genbank:AB044425")
  bioruby> puts entry
  LOCUS       AB044425                1494 bp    DNA     linear   PLN 28-APR-2001
  DEFINITION  Volvox carteri f. kawasakiensis chloroplast psaB gene for
              photosystem I P700 chlorophyll a apoprotein A2,
              strain:NIES-732.
  (略)

ent コマンドのオプションには db:entry_id 形式の文字列、ファイル、IO が
与えられ、データベースの１エントリ分の文字列が返されます。
扱えるデータベースの種類も配列データベースに限らず数多く対応しています。

--- flatparse

取得したエントリをパースして欲しいデータをとりだすには flatparse
コマンドを使います。

  bioruby> entry = ent("gbphg.seq")
  bioruby> gb = flatparse(entry)
  bioruby> puts gb.entry_id
  AB000833
  bioruby> puts gb.definition
  Bacteriophage Mu DNA for ORF1, sheath protein gpL, ORF2, ORF3, complete cds.
  bioruby> puts psaB.naseq
  acggtcagacgtttggcccgaccaccgggatgaggctgacgcaggtcagaaatctttgtgacgacaaccgtatcaat
  (略)

--- flatfile

ent コマンドは１エントリしか扱えないため、ローカルのファイルを開いて 
各エントリ毎に処理を行うには flatfile コマンドを使います。

  bioruby> flatfile("gbphg.seq") do |entry|
  bioruby+   # do something on entry
  bioruby+ end

--- flatauto

各エントリを flatparse と同様にパースした状態で順番に処理するためには、
flatfile コマンドの代わりに flatauto コマンドを使います。

  bioruby> flatauto("gbphg.seq") do |entry|
  bioruby+   print entry.entry_id
  bioruby+   puts  entry.definition
  bioruby+ end

=== フラットファイルのインデクシング

EMBOSS の dbiflat に似た機能として、BioRuby, BioPerl などに共通の BioFlat
というインデックスを作成する仕組みがあります。一度インデックスを
作成しておくとエントリの取り出しが高速かつ容易に行えます。
これにより自分専用のデータベースを手軽に作ることができます。

--- flatindex

GenBank のファージの配列ファイル gbphg.seq に入っているエントリに対して
mydb というデータベース名でインデックスを作成します。

  bioruby> flatindex("mydb", "gbphg.seq")
  Creating BioFlat index (.bioruby/bioflat/mydb) ... done

--- flatsearch

作成した mydb データベースからエントリをとり出すには flatsearch コマンドを
使います。

  bioruby> entry = flatsearch("mydb", "AB004561")
  bioruby> puts entry
  LOCUS       AB004561                2878 bp    DNA     linear   PHG 20-MAY-1998
  DEFINITION  Bacteriophage phiU gene for integrase, complete cds, integration
              site.
  ACCESSION   AB004561
  (略)

=== 様々な DB の配列を FASTA フォーマットに変換して保存

FASTA フォーマットは配列データで標準的に用いられているフォーマットです。
「>」記号ではじまる１行目に配列の説明があり、２行目以降に配列がつづきます。
配列中の空白文字は無視されます。

  >entry_id definition ...
  ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT
  ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT

配列の説明行は、最初の単語が配列の ID になっていることが多いのですが、
NCBI の BLAST 用データベースではさらに高度な構造化がおこなわれています。

* ((<URL:ftp://ftp.ncbi.nih.gov/blast/documents/README.formatdb>))
* ((<URL:http://blast.wustl.edu/doc/FAQ-Indexing.html#Identifiers>))
* FASTA format (Wikipedia)
  ((<URL:http://en.wikipedia.org/wiki/Fasta_format>))

BioRuby のデータベースエントリのクラスにはエントリID、配列、定義について
共通のメソッドが用意されています。

* entry_id - エントリ ID を取得
* definition - 定義文を取得
* seq - 配列を取得

これらの共通メソッドを使うと、どんな配列データベースエントリでも
FASTA フォーマットに変換できるプログラムが簡単に作れます。

  entry.seq.to_fasta("#{entry.entry_id} #{entry.definition}", 60)

さらに、BioRuby では入力データベースの形式を自動判別できますので、
GenBank, UniProt など多くの主要な配列データベースでは
ファイル名を指定するだけで FASTA フォーマットに変換できます。

--- flatfasta

入力データベースのファイル名のリストから、指定した FASTA フォーマットの
ファイルを生成するコマンドです。ここではいくつかの GenBank のファイルを
FASTA フォーマットに変換し、myfasta.fa というファイルに保存しています。

  bioruby> flatfasta("myfasta.fa", "gbphg.seq", "gbvrl1.seq", "gbvrl2.seq")
  Saving fasta file (myfasta.fa) ... 
    converting -- gbphg.gbk
    converting -- gbvrl1.gbk
    converting -- gbvrl2.gbk
  done

# === OBDA
# 
# OBDA (Open Bio Database Access) の設定ファイル
# 
# * ~/.bioinformatics/seqdatabase.ini
# 
# に従って、データベースのエントリを
# 
# * BioFlat - ローカルのファイル
# * BioFetch - HTTP によるウェブサーバ
# * BioSQL - RDBM
# 
# など様々なソースから生物学データベースエントリを取得することができます。
# 
#   bioruby> obda_get_entry("embl:BUM")
# 

=== KEGG API

BioRuby シェルでは KEGG API も簡単に利用できます。

--- keggdbs

ゲノムネットで KEGG API を通じて利用可能なデータベースのリストを表示します。

  bioruby> keggdbs
  nt:     Non-redundant nucleic acid sequence database
  aa:     Non-redundant protein sequence database
  gb:     GenBank nucleic acid sequence database
  (略)

--- keggorgs

KEGG に収録されている全生物種のリストを表示します。

  bioruby> keggorgs
  aae:    Aquifex aeolicus
  aci:    Acinetobacter sp. ADP1
  afu:    Archaeoglobus fulgidus
  (略)

--- keggpathways

KEGG に収録されている全パスウェイのリストを表示します。

  bioruby> keggpathways
  path:map00010:  Glycolysis / Gluconeogenesis - Reference pathway
  path:map00020:  Citrate cycle (TCA cycle) - Reference pathway
  path:map00030:  Pentose phosphate pathway - Reference pathway
  (略)

引数に３文字の KEGG 生物種記号をあたえると、その生物で利用できる
パスウェイだけの一覧を返します。大腸菌 eco の場合以下のようになります。

  bioruby> keggpathways("eco")
  path:eco00010:  Glycolysis / Gluconeogenesis - Escherichia coli K-12 MG1655
  path:eco00020:  Citrate cycle (TCA cycle) - Escherichia coli K-12 MG1655
  path:eco00030:  Pentose phosphate pathway - Escherichia coli K-12 MG1655
  (略)

--- keggapi

これら以外の KEGG API のメソッドは、keggapi に続けて呼び出すことで
利用できます。

  bioruby> p keggapi.get_genes_by_pathway("path:eco00010")
  ["eco:b0114", "eco:b0115", "eco:b0116", "eco:b0356", "eco:b0688", (略)

利用可能なメソッドの一覧は KEGG API のマニュアルを参照してください。

* ((<URL:http://www.genome.jp/kegg/soap/doc/keggapi_manual_ja.html>))

=== DBGET

ゲノムネットの DBGET のコマンドである binfo, bfind, bget, btit, bconv は
KEGG API を利用してそのまま実行できるようになっています。

--- binfo

  bioruby> binfo
                           *** Last database updates ***
  Date      Database              Release              #Entries      #Residues
 --------  -------------   ------------------------  ------------  ----------------
  05/12/06  nr-nt                 05-12-04 (Dec 05)    63,078,043   111,609,773,616
  05/12/06  nr-aa                 05-12-05 (Dec 05)     2,682,790       890,953,839
  05/10/25  genbank                  150.0 (Oct 05)    49,152,445    53,655,236,500
  05/12/06  genbank-upd       150.0+/12-04 (Dec 05)     7,470,976     6,357,888,366
  (略)

binfo コマンドに続けてデータベース名を指定することでより詳細な情報が
表示されます。

  bioruby> binfo "genbank"
  genbank          GenBank nucleic acid sequence database
  gb               Release 150.0, Oct 05
                   National Center for Biotechnology Information
                   49,152,445 entries, 53,655,236,500 bases
                   Last update:  05/10/25
                   <dbget> <fasta> <blast>

--- bfind

bfind コマンドでデータベースに対するキーワードサーチを行うことができます。
データベース名と検索したいキーワードを文字列で渡します。

  bioruby> list = bfind "genbank ebola human"
  bioruby> puts list
  gb:BD177378 [BD177378] A monoclonal antibody recognizing ebola virus.
  gb:BD177379 [BD177379] A monoclonal antibody recognizing ebola virus.
  (略)

--- bget

bget コマンドで指定した db:entry_id のデータベースエントリを取得できます。

  bioruby> entry = bget "gb:BD177378"
  bioruby> puts entry
  LOCUS       BD177378                  24 bp    DNA     linear   PAT 16-APR-2003
  DEFINITION  A monoclonal antibody recognizing ebola virus.
  (略)


=== スクリプト生成

作業手順をスクリプト化して保存しておくこともできます。

  bioruby> script
  -- 8< -- 8< -- 8< --  Script  -- 8< -- 8< -- 8< --
  bioruby> seq = seq("gbphg.seq")
  bioruby> p seq
  bioruby> p seq.translate
  bioruby> script
  -- >8 -- >8 -- >8 --  Script  -- >8 -- >8 -- >8 --
  Saving script (.bioruby/script.rb) ... done

生成された .bioruby/script.rb は以下のようになります。

  #!/usr/bin/env ruby
  
  require 'bio/shell'
  
  include Bio::Shell
  
  Bio::Shell.setup
  
  seq = seq("gbphg.seq")
  p seq
  p seq.translate

このスクリプトを ruby で実行することができます。

  % ruby .bioruby/script.rb

=== 簡易シェル機能

--- cd

カレントディレクトリを変更します。

  bioruby> cd "/tmp"
  "/tmp"

ホームディレクトリに戻るには引数をつけずに cd を実行します。

  bioruby> cd
  "/home/k"

--- pwd

カレントディレクトリを表示します。

  bioruby> pwd
  "/home/k"

--- dir

カレントディレクトリのファイルを一覧表示します。

  bioruby> dir
     UGO  Date                                 Byte  File
  ------  ----------------------------  -----------  ------------
   40755  Tue Nov 29 16:55:20 JST 2005         2176  "bin"
  100644  Sat Oct 15 03:01:00 JST 2005     42599518  "gbphg.seq"
   40755  Wed Oct 26 19:26:27 JST 2005          170  "lib"
  (略)

--- head

テキストファイルの先頭を表示します。

  bioruby> head "gbphg.seq"
  GBPHG.SEQ            Genetic Sequence Data Bank
                            October 15 2005
  
                  NCBI-GenBank Flat File Release 150.0
  
                            Phage Sequences         
  
      2713 loci,    16892737 bases, from     2713 reported sequences

行数を指定することもできます。

  bioruby> head "gbphg.seq", 2
  GBPHG.SEQ            Genetic Sequence Data Bank
                            October 15 2005

--- less

テキストファイルを PAGER で表示します。デフォルトでは環境変数 PAGER
の値か less コマンドを使用します。

  bioruby> less "gbphg.seq"

=== 変数

--- ls

セッション中に作成した変数（オブジェクト）の一覧を表示します。

  bioruby> ls
  ["entry", "seq"]

  bioruby> a = 123
  ["a", "entry", "seq"]

--- rm

変数を消去します。

  bioruby> rm "a"

  bioruby> ls
  ["entry", "seq"]

--- savefile

変数に保存されている内容をテキストファイルに保存します。

  bioruby> savefile "testfile.txt", entry
  Saving data (testfile.txt) ... done

  bioruby> less "testfile.txt"

=== 各種設定

永続化の仕組みとして BioRuby シェル終了時に .bioruby ディレクトリ内に
ヒストリ、オブジェクト、個人の設定が保存され、次回起動時に自動的に
読み込まれます。

--- config

BioRuby シェルの各種設定を表示します。

  bioruby> config
  message = "...BioRuby in the shell..."
  marshal = [4, 8]
  color   = false
  pager   = nil
  echo    = false

echo 表示するかどうかを切り替えます。

  bioruby> config :echo
  Echo on
    ==> nil

  bioruby> config :echo
  Echo off

可能な場合にカラー表示するかどうかを切り替えます。
カラー表示の場合、プロンプトにも色がつきますので判別できます。

  bioruby> config :color
  bioruby> codontable
  (色付き)
  bioruby> config :color
  bioruby> codontable
  (色なし)

--- pager

less などで利用する PAGER を設定します。

  bioruby> pager "more"
  Pager is set to 'more'

PAGER を使用しない設定にする場合は引数なしで実行します。

  bioruby> pager
  Pager is set to 'off'

=== 遺伝子音楽

--- midifile

DNA 配列を MIDI ファイルに変換するオマケ機能があります。
適当な塩基配列 seq を使って生成した midifile.mid を
MIDI プレイヤーで演奏してみましょう。

  bioruby> midifile("midifile.mid", seq)
  Saving MIDI file (midifile.mid) ... done

以上で BioRuby シェルの解説を終わり、以下では BioRuby ライブラリ自体の
解説を行います。


== 塩基・アミノ酸配列を処理する (Bio::Sequence クラス)

Bio::Sequence クラスは、配列に対する様々な操作を行うことができます。
簡単な例として、短い塩基配列 atgcatgcaaaa を使って、相補配列への変換、
部分配列の切り出し、塩基組成の計算、アミノ酸への翻訳、分子量計算などを
行なってみます。アミノ酸への翻訳では、必要に応じて何塩基目から翻訳を開
始するかフレームを指定したり、codontable.rb で定義されているコドンテー
ブルの中から使用するものを指定したりする事ができます。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    seq = Bio::Sequence::NA.new("atgcatgcaaaa")
    
    puts seq                            # 元の配列
    puts seq.complement                 # 相補配列 (Sequence::NA オブジェクト)
    puts seq.subseq(3,8)                # 3 塩基目から 8 塩基目まで
    
    p seq.gc_percent                    # GC 塩基の割合 (bioruby 0.6以前: Float 0.7以降: Integer)
    p seq.composition                   # 全塩基組成 (Hash)
    
    puts seq.translate                  # 翻訳配列 (Sequence::AA オブジェクト)
    puts seq.translate(2)               # ２文字目から翻訳（普通は１から）
    puts seq.translate(1,11)            # 11番目のコドンテーブルを使用
                                        # (コドンテーブルの番号は http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi を参照。)
    
    p seq.translate.codes               # アミノ酸を３文字コードで表示 (Array)
    p seq.translate.names               # アミノ酸を名前で表示 (Array)
    p seq.translate.composition         # アミノ酸組成 (Hash)
    p seq.translate.molecular_weight    # 分子量を計算 (Float)
    
    puts seq.complement.translate       # 相補配列の翻訳

pやprintやputsは指定した内容を表示するためのRuby標準メソッドです。
Ruby標準装備のクラスやメソッドについては、
((<Rubyのリファレンスマニュアル|URL:http://www.ruby-lang.org/ja/man/>))
を参照してください。(Windows版Rubyならヘルプも使えるかもしれません。)
英語での表示になりますが、riコマンドも使えます。

  % ri p

(日本語でコマンドラインからリファレンスマニュアルを見たい場合は、
((<refe|URL:http://i.loveruby.net/ja/prog/refe.html>))
をインストールするのがお勧めです。)

塩基配列は Bio::Sequence::NA クラスの、アミノ酸配列は Bio::Sequence::AA
クラスのオブジェクトになります。それぞれ Bio::Sequence クラスを継承し
ているため、多くのメソッドは共通です。

Bio::Sequence クラスは Ruby の String クラスを継承しているので String
クラスが持つメソッドも使う事ができます。例えば部分配列を切り出すには
subseq(from,to) の他に、String の [] メソッドも使うことができます。
ただし、Ruby の文字列は 1 文字目を 0 番目として数える点には注意が必要です。
たとえば、

  s = 'abc'
  puts s[0..0]

  >a

Stringのメソッドを使う場合は、生物学で普通使用される1文字目を1番目として
数えた場所の数字からは 1 を引く必要があります。（subseq メソッドはこれを
内部でやっています。また、from, to のどちらかでも 0 以下の場合は nil を
返すようになっています。）

window_search(window_size, step_size) メソッドを使うと、配列に対してウィ
ンドウをずらしながらそれぞれの部分配列に対する処理を行うことができます。
Rubyの特長のひとつである「ブロック」によって、「それぞれに対する処理」を
簡潔かつ明瞭に書くことが可能です。以下の例では、's' という変数にそれぞれ
部分配列を代入しながらブロックを繰り返し実行することになります。

* 100 塩基ごとに（1塩基ずつずらしながら）平均 GC% を計算して表示する

    seq.window_search(100) do |s|
      puts s.gc_percent
    end

ブロックの中で受け取る部分配列も、元と同じ Bio::Sequence::NA または 
Bio::Sequence::AA クラスのオブジェクトなので、配列クラスの持つ全てのメ
ソッドを実行することができます。

また、２番目の引数に移動幅を指定することが出来るようになっているので、

* コドン単位でずらしながら 15 塩基を翻訳して表示する

    seq.window_search(15, 3) do |s|
      puts s.translate
    end

といったことができます。さらに移動幅に満たない右端の部分配列をメソッド
自体の返り値として戻すようになっているので、

* ゲノム配列を 10000bp ごとにブツ切りにして FASTA フォーマットに整形、
  このとき末端 1000bp はオーバーラップさせ、10000bp に満たない 3' 端は
  別途受け取って表示する

    i = 1
    remainder = seq.window_search(10000, 9000) do |s|
      puts s.to_fasta("segment #{i}", 60)
      i += 1
    end
    puts remainder.to_fasta("segment #{i}", 60)

のような事もわりと簡単にできます。

ウィンドウの幅と移動幅を同じにするとオーバーラップしないウィンドウサー
チができるので、

* コドン頻度を数える

    codon_usage = Hash.new(0)
    seq.window_search(3, 3) do |subseq|
      codon_usage[subseq] += 1
    end

* 10 残基ずつ分子量を計算

    seq.window_search(10, 10) do |subseq|
      puts subseq.molecular_weight
    end

といった応用も考えられます。

実際には Bio::Sequence::NA オブジェクトはファイルから読み込んだ文字列か
ら生成したり、データベースから取得したものを使ったりします。たとえば、

    #!/usr/bin/env ruby
    
    require 'bio'
    
    input_seq = ARGF.read       # 引数で与えられたファイルの全行を読み込む
    
    my_naseq = Bio::Sequence::NA.new(input_seq)
    my_aaseq = my_naseq.translate
    
    puts my_aaseq

このプログラムを na2aa.rb として、以下の塩基配列

      gtggcgatctttccgaaagcgatgactggagcgaagaaccaaagcagtgacatttgtctg
      atgccgcacgtaggcctgataagacgcggacagcgtcgcatcaggcatcttgtgcaaatg
      tcggatgcggcgtga

を書いたファイル my_naseq.txt を読み込んで翻訳すると

    % ./na2aa.rb my_naseq.txt
    VAIFPKAMTGAKNQSSDICLMPHVGLIRRGQRRIRHLVQMSDAA*

のようになります。ちなみに、このくらいの例なら短くすると１行で書けます。

    % ruby -r bio -e 'p Bio::Sequence::NA.new($<.read).translate' my_naseq.txt

しかし、いちいちファイルを作るのも面倒なので、次はデータベースから必要な
情報を取得してみます。


== GenBank のパース (Bio::GenBank クラス)

GenBank 形式のファイルを用意してください。(なければ、
ftp://ftp.ncbi.nih.gov/genbank/ から .seq ファイルをダウンロードすること。)

まずは、各エントリから ID と説明文、配列を取り出して FASTA 形式に変換して
みましょう。なお、これと同じような例はBioRubyのサンプルスクリプトにも入って
います。

Bio::GenBank::DELIMITER は GenBank クラスで定義されている定数で、
データベースごとに異なるエントリの区切り文字（たとえば GenBank の場合は //）
を覚えていなくても良いようになっています。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    while entry = gets(Bio::GenBank::DELIMITER)
      gb = Bio::GenBank.new(entry)      # GenBank オブジェクト
    
      print ">#{gb.accession} "         # ACCESSION 番号
      puts gb.definition                # DEFINITION 行
      puts gb.naseq                     # 塩基配列（Sequence::NA オブジェクト）
    end

しかし、これはGenBankファイルのデータ構造に依存しています。
ファイルからのデータ入力を扱うクラス Bio::FlatFile を使用することで、
以下のようにより汎用的に書くことができます。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ff = Bio::FlatFile.new(Bio::GenBank, ARGF)
    ff.each_entry do |gb|
      definition = "#{gb.accession} #{gb.definition}"
      puts gb.naseq.to_fasta(definition, 60)    
    end

形式の違うデータ、たとえばFASTAフォーマットのファイルを読み込むときでも、

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ff = Bio::FlatFile.new(Bio::FastaFormat, ARGF)
    ff.each_entry do |f|
      puts "definition : " + f.definition
      puts "nalen      : " + f.nalen.to_s
      puts "naseq      : " + f.naseq
    end

のように、似た書き方で済ませられます。

上の例では、Bio::FlatFile.new の最初の引数にデータベースファイルのフォー
マットを BioRuby のクラス名で指定しています。これについて詳しくは次の
セクションを参照してください。

さらに、各 Bio::DB クラスの open メソッドで同様のことができます。たとえば、

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ff = Bio::GenBank.open("gbvrl1.seq")
    ff.each_entry do |gb|
      definition = "#{gb.accession} #{gb.definition}"
      puts gb.naseq.to_fasta(definition, 60)    
    end

などと書くことができます。(ただし、この書き方はあまり使われていません。)

次に、GenBank の複雑な FEATURES の中をパースして、遺伝子ごとの塩基配列と
アミノ酸配列を取り出してみます。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ff = Bio::FlatFile.new(Bio::GenBank, ARGF)

    # GenBank の１エントリごとに
    ff.each_entry do |gb|

      # ACCESSION 番号と生物種名を表示
      puts "# #{gb.accession} - #{gb.organism}"
    
      gb.features.each do |feature|     # FEATURES の要素を一つずつ処理
        position = feature.position
        hash = feature.assoc            # レガシーだが簡単のためハッシュに直す

        # /translation= がなければスキップ
        next unless hash['translation']

        # 遺伝子名などの情報を集める
        gene_info = [
          hash['gene'], hash['product'], hash['note'], hash['function']
        ].compact.join(', ')

        # 塩基配列
        puts ">NA splicing('#{position}') : #{gene_info}"
        puts gb.naseq.splicing(position)

        # アミノ酸配列（塩基配列から翻訳）
        puts ">AA translated by splicing('#{position}').translate"
        puts gb.naseq.splicing(position).translate

        # アミノ酸配列（/translation= のもの）
        puts ">AA original translation"
        puts hash['translation']
      end
    end

* 注：上記のように assoc メソッドで Feature オブジェクトからハッシュを生成
  すると qualifier をキーとしてデータを取り出すことができるので便利ですが、
  キーが同一の複数の qualifier が 1 つの feature 中に存在する場合、情報が
  失われます（これを防ぐためにFeature#featureメソッドではデータを配列で
  持たせています）。

上の例で使用されている Bio::Sequence#splicing メソッドは、GenBank,EMBL,DDBJ
フォーマットのLocationの表記を元に、塩基配列から部分配列を切り出す強力な
メソッドです。

もし、データで使用しているコドンテーブルがデフォルト(universal)と違ったり、
最初のコドンが "atg" 以外だったり、セレノシステインが含まれていたり、
あるいは BioRuby にバグがあれば、上の例の最後の2行で表示されるアミノ酸配列
が異なる事になります。

この splicing メソッドの引数には GenBank の Feature で使われている形式の
文字列以外に Bio::Locations オブジェクトを渡すことも可能です。
Location文字列のフォーマットや Bio::Locations について詳しく知りたい場合は 
bio/location.rb を見てください。

* GenBank形式のデータの Feature で使われていたLocation文字列の例

    naseq.splicing('join(2035..2050,complement(1775..1818),13..345')

* あらかじめ Locations オブジェクトに変換してから渡してもよい

    locs = Bio::Locations.new('join((8298.8300)..10206,1..855)')
    naseq.splicing(locs)

ちなみに、アミノ酸配列 (Bio::Sequence::AA) についても splicing メソッド
を使用して部分配列を取り出すことが可能です。

* アミノ酸配列の部分配列を切り出す(たとえばシグナルペプチドとか)

    aaseq.splicing('21..119')


=== GenBank 以外のデータベース

BioRuby では、GenBank 以外のデータベースについても基本的なやり方は同じで、
データベースの１エントリを対応するデータベースのクラスに渡せば、パースさ
れた結果がオブジェクトになって返ってきます。

データベースのフラットファイルから１エントリずつ取り出してパースされた
オブジェクトを取り出すには、先にも出てきた Bio::FlatFile を使います。
Bio::FlatFile.new の引数にはデータベースに対応する BioRuby でのクラス
名 (Bio::GenBank や Bio::KEGG::GENES など) を指定します。

    ff = Bio::FlatFile.new(Bio::データベースクラス名, ARGF)

が、すばらしいことに、実は FlatFile クラスはデータベースの自動認識がで
きますので、

    ff = Bio::FlatFile.auto(ARGF)

を使うのが一番簡単です。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ff = Bio::FlatFile.auto(ARGF)
    ff.each_entry do |entry|
      p entry.entry_id          # エントリの ID
      p entry.definition        # エントリの説明文
      p entry.seq               # 配列データベースの場合
    end

パースされたオブジェクトから、エントリ中のそれぞれの部分を取り出すための
メソッドはデータベース毎に異なります。よくある項目については

  * entry_id メソッド → エントリの ID 番号が返る
  * definition メソッド → エントリの定義行が返る
  * reference メソッド → リファレンスオブジェクトが返る
  * organism メソッド → 生物種名
  * seq や naseq や aaseq メソッド → 対応する配列オブジェクトが返る

などのように共通化しようとしていますが、全てのメソッドが実装されているわ
けではありません（共通化の指針は bio/db.rb 参照）。また、細かい部分は各
データベースパーザ毎に異なるので、それぞれのドキュメントに従います。

原則として、メソッド名が複数形の場合は、オブジェクトが配列として返ります。
たとえば references メソッドを持つクラスは複数の Bio::Reference オブジェ
クトを Array にして返しますが、別のクラスでは単数形の reference メソッド
しかなく、１つの Bio::Reference オブジェクトだけを返す、といった感じです。


=== アライメント (Bio::Alignment クラス)

Bio::Alignmentクラス (bio/alignment.rb に記述されています) はRubyのHash
やArray、あるいは BioPerl の Bio::SimpleAlign に似た感じの、アライメントを
格納するコンテナクラスです。以下に簡単な使い方を示します。

  require 'bio'

  seqs = [ 'atgca', 'aagca', 'acgca', 'acgcg' ]
  seqs = seqs.collect{ |x| Bio::Sequence::NA.new(x) }

  # アライメントオブジェクトを作成
  a = Bio::Alignment.new(seqs)

  # コンセンサス配列を表示
  p a.consensus             # ==> "a?gc?"

  # IUPAC標準の曖昧な塩基を使用したコンセンサス配列を表示
  p a.consensus_iupac       # ==> "ahgcr"

  # 各配列について繰り返す
  a.each { |x| p x }
    # ==>
    #    "atgca"
    #    "aagca"
    #    "acgca"
    #    "acgcg"
  # 各サイトについて繰り返す
  a.each_site { |x| p x }
    # ==>
    #    ["a", "a", "a", "a"]
    #    ["t", "a", "c", "c"]
    #    ["g", "g", "g", "g"]
    #    ["c", "c", "c", "c"]
    #    ["a", "a", "a", "g"]

  # CLUSTAL W を使用してアライメントを行う。
  # clustalwコマンドがシステムにインストールされている必要がある。
  factory = Bio::ClustalW.new
  a2 = a.do_align(factory)


== FASTA による相同性検索を行う（Bio::Fasta クラス）

FASTA 形式の配列ファイル query.pep に対して、自分のマシン(ローカル)あるいは
インターネット上のサーバ(リモート)で FASTA による相同性検索を行う方法です。
ローカルの場合は SSEARCH なども同様に使うことができます。

=== ローカルの場合

FASTA がインストールされていることを確認してください。（コマンド名が
 fasta34 でパスが通ったディレクトリにインストールされていると仮定します。
無い場合は ftp://ftp.virginia.edu/pub/fasta/ からダウンロードおよび
インストールを行ってください。）検索対象とする FASTA 形式のデータ
ベースファイル target.pep と、FASTA 形式で問い合わせ配列がいくつか入った
ファイル query.pep を準備し、

    #!/usr/bin/env ruby
    
    require 'bio'
    
    # FASTA を実行する環境オブジェクトを作る（ssearch などでも良い）
    factory = Bio::Fasta.local('fasta34', ARGV.pop)
    
    # フラットファイルを読み込み、FastaFormat オブジェクトのリストにする
    ff = Bio::FlatFile.new(Bio::FastaFormat, ARGF)
    
    # １エントリずつの FastaFormat オブジェクトに対し
    ff.each do |entry|
      # '>' で始まるコメント行の内容を進行状況がわりに標準エラー出力に表示
      $stderr.puts "Searching ... " + entry.definition
   
      # FASTA による相同性検索を実行、結果は Fasta::Report オブジェクト
      report = factory.query(entry)
    
      # ヒットしたものそれぞれに対し
      report.each do |hit|
        # evalue が 0.0001 以下の場合
        if hit.evalue < 0.0001
          # その evalue と、名前、オーバーラップ領域を表示
          print "#{hit.query_id} : evalue #{hit.evalue}\t#{hit.target_id} at "
          p hit.lap_at
        end
      end
    end

というスクリプトを f_search.rb という名前で作ったとすると、

    % ./f_search.rb query.pep target.pep > f_search.out

のように実行すれば検索することができます。

ここで factory は繰り返し FASTA を実行するために、あらかじめ作っておく実
行環境です。上の例では Fasta オブジェクトの query メソッドを使って検索し
ていますが、逆に問い合わせ配列に対し

    seq = ">test seq\nYQVLEEIGRGSFGSVRKVIHIPTKKLLVRKDIKYGHMNSKE"
    seq.fasta(factory)

のように factory を渡して fasta メソッドを呼ぶ方法もあります。
(TRANSLATOR'S NOTE: この機能は将来無くなるかもしれない。)

FASTA コマンドにオプションを与えたい場合、３番目の引数に FASTA のコマン
ドラインオプションを書いて渡します。ktup 値だけはメソッドで指定します。
たとえば ktup 値を 1 にして、トップ 10 位以内のヒットを得る場合のオプショ
ンは、以下のようになります。

    factory = Bio::Fasta.local('fasta34', 'target.pep', '-b 10')
    factory.ktup = 1

Bio::Fasta#query メソッドなどの返り値は Bio::Fasta::Report オブジェクト
です。この Report オブジェクトから、様々なメソッドで FASTA の出力結果の
ほぼ全てを自由に取り出せるようになっています。たとえば、ヒットに関する
スコアなどの主な情報は、

    report.each do |hit|
      puts hit.evalue           # E-value
      puts hit.sw               # Smith-Waterman スコア (*)
      puts hit.identity         # % identity
      puts hit.overlap          # オーバーラップしている領域の長さ 
      puts hit.query_id         # 問い合わせ配列の ID
      puts hit.query_def        # 問い合わせ配列のコメント
      puts hit.query_len        # 問い合わせ配列の長さ
      puts hit.query_seq        # 問い合わせ配列
      puts hit.target_id        # ヒットした配列の ID
      puts hit.target_def       # ヒットした配列のコメント
      puts hit.target_len       # ヒットした配列の長さ
      puts hit.target_seq       # ヒットした配列
      puts hit.query_start      # 相同領域の問い合わせ配列での開始残基位置
      puts hit.query_end        # 相同領域の問い合わせ配列での終了残基位置
      puts hit.target_start     # 相同領域のターゲット配列での開始残基位置
      puts hit.target_end       # 相同領域のターゲット配列での終了残基位置
      puts hit.lap_at           # 上記４位置の数値の配列
    end

などのメソッドで呼び出せます。これらのメソッドの多くは後で説明する
Bio::Blast::Report クラスと共通にしてあります。上記以外のメソッドや
FASTA 特有の値を取り出すメソッドが必要な場合は、Bio::Fasta::Report
クラスのドキュメントを参照してください。

もし、パースする前の手を加えていない fasta コマンドの実行結果が必要な
場合には、

    report = factory.query(entry)
    puts factory.output

のように、query メソッドを実行した後で factory オブジェクトの output
メソッドを使ってください。


=== リモートの場合

今のところ GenomeNet (fasta.genome.jp) での検索のみサポートしています。
リモートの場合は使用可能な検索対象データベースが決まっていますが、それ以
外の点については Bio::Fasta.remote と Bio::Fasta.local は同じように使う
ことができます。

GenomeNet で使用可能な検索対象データベース：

  * アミノ酸配列データベース
    * nr-aa, genes, vgenes.pep, swissprot, swissprot-upd, pir, prf, pdbstr

  * 塩基配列データベース
    * nr-nt, genbank-nonst, gbnonst-upd, dbest, dbgss, htgs, dbsts,
      embl-nonst, embnonst-upd, genes-nt, genome, vgenes.nuc

まず、この中から検索したいデータベースを選択します。問い合わせ配列の種類
と検索するデータベースの種類によってプログラムは決まります。

  * 問い合わせ配列がアミノ酸のとき
    * 対象データベースがアミノ酸配列データベースの場合、program は 'fasta'
    * 対象データベースが核酸配列データベースの場合、program は 'tfasta'

  * 問い合わせ配列が核酸配列のとき
    * 対象データベースが核酸配列データベースの場合、program は 'fasta'
    * (対象データベースがアミノ酸配列データベースの場合は検索不能?)

プログラムとデータベースの組み合せが決まったら

    program = 'fasta'
    database = 'genes'
    
    factory = Bio::Fasta.remote(program, database)

としてファクトリーを作り、ローカルの場合と同じように factory.query など
のメソッドで検索を実行します。


== BLAST による相同性検索を行う（Bio::Blast クラス）

BLAST もローカルと GenomeNet (blast.genome.jp) での検索をサポートして
います。できるだけ Bio::Fasta と API を共通にしていますので、上記の例を 
Bio::Blast と書き換えただけでも大丈夫な場合が多いです。

たとえば、先の f_search.rb は

    # BLAST を実行する環境オブジェクトを作る
    factory = Bio::Blast.local('blastp', ARGV.pop) 

と変更するだけで同じように実行できます。

同様に、GenomeNet を使用してBLASTを行う場合には Bio::Blast.remote を使います。
この場合、programの指定内容が FASTA と異なります。

  * 問い合わせ配列がアミノ酸のとき
    * 対象データベースがアミノ酸配列データベースの場合、program は 'blastp'
    * 対象データベースが核酸配列データベースの場合、program は 'tblastn'

  * 問い合わせ配列が塩基配列のとき
    * 対象データベースがアミノ酸配列データベースの場合、program は 'blastx'
    * 対象データベースが塩基配列データベースの場合、program は 'blastn'
    * (問い合わせ・データベース共に6フレーム翻訳を行う場合は 'tblastx')

をそれぞれ指定します。

ところで、Bio::Blast は、Ruby用のXMLライブラリである XMLParser または
REXML が使用可能な場合は、BLASTの "-m 7" オプションによるXML出力を利用
します(XMLParser のほうが高速なので優先的に使用されます) 。
なお、Ruby 1.8.0以降では REXMLはRuby本体に標準添付されています。
もしXMLライブラリがインストールされていない場合は "-m 8" のタブ区切りの
出力形式を扱うようにしています。しかし、このフォーマットでは得られる
データが限られるので、"-m 7" の XML 形式の出力を使うことをお勧めします。
(Ruby 1.8.0以降を使用すれば、特別な外部ライブラリを別途インストール
しなくても大丈夫です。Ruby 1.6.X では XMLParser または REXMLを別途
インストールしてください。)

すでに見たように Bio::Fasta::Report と Bio::Blast::Report の Hit オブジェ
クトはいくつか共通のメソッドを持っています。BLAST 固有のメソッドで良く使
いそうなものには bit_score や midline などがあります。

    report.each do |hit|
      puts hit.bit_score        # bit スコア (*)
      puts hit.query_seq        # 問い合わせ配列
      puts hit.midline          # アライメントの midline 文字列 (*)
      puts hit.target_seq       # ヒットした配列
      
      puts hit.evalue           # E-value
      puts hit.identity         # % identity
      puts hit.overlap          # オーバーラップしている領域の長さ 
      puts hit.query_id         # 問い合わせ配列の ID
      puts hit.query_def        # 問い合わせ配列のコメント
      puts hit.query_len        # 問い合わせ配列の長さ
      puts hit.target_id        # ヒットした配列の ID
      puts hit.target_def       # ヒットした配列のコメント
      puts hit.target_len       # ヒットした配列の長さ
      puts hit.query_start      # 相同領域の問い合わせ配列での開始残基位置
      puts hit.query_end        # 相同領域の問い合わせ配列での終了残基位置
      puts hit.target_start     # 相同領域のターゲット配列での開始残基位置
      puts hit.target_end       # 相同領域のターゲット配列での終了残基位置
      puts hit.lap_at           # 上記４位置の数値の配列
    end

FASTAとのAPI共通化のためと簡便のため、スコアなどいくつかの情報は1番目の
Hsp (High-scoring segment pair) の値をHitで返すようにしています。

Bio::Blast::Report オブジェクトは、以下に示すような、BLASTの結果出力の
データ構造をそのまま反映した階層的なデータ構造を持っています。具体的には

  * Bio::Blast::Report オブジェクトの @iteratinos に
    * Bio::Blast::Report::Iteration オブジェクトの Array が入っており
      Bio::Blast::Report::Iteration オブジェクトの @hits に
      * Bio::Blast::Report::Hits オブジェクトの Array が入っており
        Bio::Blast::Report::Hits オブジェクトの @hsps に
        * Bio::Blast::Report::Hsp オブジェクトの Array が入っている

という階層構造になっており、それぞれが内部の値を取り出すためのメソッドを
持っています。これらのメソッドの詳細や、BLAST 実行の統計情報などの値が
必要な場合には、 bio/appl/blast/*.rb 内のドキュメントやテストコードを
参照してください。


=== 既存の BLAST 出力ファイルをパースする

BLAST を実行した結果ファイルがすでに保存してあって、これを解析したい場合
には（Bio::Blast オブジェクトを作らずに） Bio::Blast::Report オブジェク
トを作りたい、ということになります。これには Bio::Blast.reports メソッド
を使います。対応しているのは デフォルト出力フォーマット("-m 0") または
"-m 7" オプションの XML フォーマット出力です。

    #!/usr/bin/env ruby
    
    require 'bio'

    # BLAST出力を順にパースして Bio::Blast::Report オブジェクトを返す
    Bio::Blast.reports(ARGF) do |report|
      puts "Hits for " + report.query_def + " against " + report.db
      report.each do |hit|
        print hit.target_id, "\t", hit.evalue, "\n" if hit.evalue < 0.001
      end
    end

のようなスクリプト hits_under_0.001.rb を書いて、

   % ./hits_under_0.001.rb *.xml

などと実行すれば、引数に与えた BLAST の結果ファイル *.xml を順番に処理で
きます。

Blast のバージョンや OS などによって出力される XML の形式が異なる可能性
があり、時々 XML のパーザがうまく使えないことがあるようです。その場合は
Blast 2.2.5 以降のバージョンをインストールするか -D や -m などのオプショ
ンの組み合せを変えて試してみてください。


=== リモート検索サイトを追加するには

注: このセクションは上級ユーザ向けです。

Blast 検索は NCBI をはじめ様々なサイトでサービスされていますが、今のとこ
ろ BioRuby では GenomeNet 以外には対応していません。これらのサイトは、

  * CGI を呼び出す（コマンドラインオプションはそのサイト用に処理する）
  * -m 8 など BioRuby がパーザを持っている出力フォーマットで blast の
    出力を取り出す

ことさえできれば、query を受け取って検索結果を Bio::Blast::Report.new に
渡すようなメソッドを定義するだけで使えるようになります。具体的には、この
メソッドを「exec_サイト名」のような名前で Bio::Blast の private メソッド
として登録すると、４番目の引数に「サイト名」を指定して

    factory = Bio::Blast.remote(program, db, option, 'サイト名')

のように呼び出せるようになっています。完成したら BioRuby プロジェクトま
で送ってもらえれば取り込ませて頂きます。


== PubMed を引いて引用文献リストを作る (Bio::PubMed クラス)

次は、NCBI の文献データベース PubMed を検索して引用文献リストを作成する
例です。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    ARGV.each do |id|
      entry = Bio::PubMed.query(id)     # PubMed を取得するクラスメソッド
      medline = Bio::MEDLINE.new(entry) # Bio::MEDLINE オブジェクト
      reference = medline.reference     # Bio::Reference オブジェクト
      puts reference.bibtex             # BibTeX フォーマットで出力
    end

このスクリプトを pmfetch.rb など好きな名前で保存し、

    % ./pmfetch.rb 11024183 10592278 10592173

など引用したい論文の PubMed ID (PMID) を引数に並べると NCBI にアクセスし
て MEDLINE フォーマットをパースし BibTeX フォーマットに変換して出力して
くれるはずです。

他に、キーワードで検索する機能もあります。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    # コマンドラインで与えたキーワードのリストを１つの文字列にする
    keywords = ARGV.join(' ')
    
    # PubMed をキーワードで検索
    entries = Bio::PubMed.search(keywords)
    
    entries.each do |entry|
      medline = Bio::MEDLINE.new(entry) # Bio::MEDLINE オブジェクト
      reference = medline.reference     # Bio::Reference オブジェクト
      puts reference.bibtex             # BibTeX フォーマットで出力
    end

このスクリプトを pmsearch.rb など好きな名前で保存し

    % ./pmsearch.rb genome bioinformatics

など検索したいキーワードを引数に並べて実行すると、PubMed をキーワード
検索してヒットした論文のリストを BibTeX フォーマットで出力します。

最近では、NCBI は E-Utils というウェブアプリケーションを使うことが
推奨されているので、今後は Bio::PubMed.esearch メソッドおよび
Bio::PubMed.efetch メソッドを使う方が良いでしょう。

    #!/usr/bin/env ruby
    
    require 'bio'
    
    keywords = ARGV.join(' ')
    
    options = {
      'maxdate' => '2003/05/31',
      'retmax' => 1000,
    }
    
    entries = Bio::PubMed.esearch(keywords, options)
    
    Bio::PubMed.efetch(entries).each do |entry|
      medline = Bio::MEDLINE.new(entry)
      reference = medline.reference
      puts reference.bibtex
    end

このスクリプトでは、上記の pmsearch.rb とほぼ同じように動きます。さらに、
NCBI E-Utils を活用することにより、検索対象の日付や最大ヒット件数などを
指定できるようになっているので、より高機能です。オプションに与えられる
引数については ((<E-Utils のヘルプページ|URL:http://eutils.ncbi.nlm.nih.gov/entrez/query/static/eutils_help.html>)) を参照してください。

ちなみに、ここでは bibtex メソッドで BibTeX フォーマットに変換しています
が、後述のように bibitem メソッドも使える他、nature メソッドや nar など
いくつかの雑誌のフォーマットにも対応しています（強調やイタリックなど
文字の修飾はできないのでそのまま使用することはできませんが）。

=== BibTeX の使い方のメモ

上記の例で集めた BibTeX フォーマットのリストを TeX で使う方法を簡単にま
とめておきます。引用しそうな文献を

    % ./pmfetch.rb 10592173 >> genoinfo.bib
    % ./pmsearch.rb genome bioinformatics >> genoinfo.bib

などとして genoinfo.bib ファイルに集めて保存しておき、

    \documentclass{jarticle}
    \begin{document}
    \bibliographystyle{plain}
    ほにゃらら KEGG データベース~\cite{PMID:10592173}はふがほげである。
    \bibliography{genoinfo}
    \end{document}

というファイル hoge.tex を書いて、

    % platex hoge
    % bibtex hoge   # → genoinfo.bib の処理
    % platex hoge   # → 文献リストの作成
    % platex hoge   # → 文献番号

とすると無事 hoge.dvi ができあがります。
    
=== bibitem の使い方のメモ

文献用に別の .bib ファイルを作りたくない場合は Reference#bibitem メソッ
ドの出力を使います。上記の pmfetch.rb や pmsearch.rb の

    puts reference.bibtex

の行を

    puts reference.bibitem

に書き換えるなどして、出力結果を

    \documentclass{jarticle}
    \begin{document}
    ほにゃらら KEGG データベース~\cite{PMID:10592173}はふがほげである。

    \begin{thebibliography}{00}

    \bibitem{PMID:10592173}
    Kanehisa, M., Goto, S.
    KEGG: kyoto encyclopedia of genes and genomes.,
    {\em Nucleic Acids Res}, 28(1):27--30, 2000.

    \end{thebibliography}
    \end{document}

のように \begin{thebibliography} で囲みます。これを hoge.tex とすると

    % platex hoge   # → 文献リストの作成
    % platex hoge   # → 文献番号

と２回処理すればできあがりです。


= OBDA

OBDA (Open Bio Database Access) とは、Open Bioinformatics Foundation
によって制定された、配列データベースへの共通アクセス方法です。これは、
2002 年の1月と2月に Arizona と Cape Town にて開催された BioHackathon
において、BioPerl, BioJava, BioPython, BioRuby などの各プロジェクトの
メンバーが参加して作成されました。

* BioRegistry (Directory)
  * データベース毎に配列をどこにどのように取りに行くかを指定する仕組み

* BioFlat
  * フラットファイルの 2 分木または BDB を使ったインデックス作成

* BioFetch
  * HTTP 経由でデータベースからエントリを取得するサーバとクライアント

* BioSQL
  * MySQL や PostgreSQL などの関係データベースに配列データを格納する
    ための schema と、エントリを取り出すためのメソッド

詳細は ((<URL:http://obda.open-bio.org/>)) を参照してください。
それぞれの仕様書は cvs.open-bio.org の CVSレポジトリに置いてあります。
または、((<URL:http://cvs.open-bio.org/cgi-bin/viewcvs/viewcvs.cgi/obda-specs/?cvsroot=obf-common>)) から参照できます。


== BioRegistry

BioRegistryとは、設定ファイルによって各データベースのエントリ取得方法を
指定することにより、どんな方法を使っているかをほとんど意識せずデータを
取得することを可能とするための仕組みです。
設定ファイルの優先順位は

  * (メソッドのパラメータで)指定したファイル
  * ~/.bioinformatics/seqdatabase.ini
  * /etc/bioinformatics/seqdatabase.ini
  * http://www.open-bio.org/registry/seqdatabase.ini

最後の open-bio.org の設定は、ローカルな設定ファイルが見つからない場合に
だけ参照します。

BioRuby の現在の実装では、すべてのローカルな設定ファイルを読み込み、
同じ名前の設定が複数存在した場合は、最初に見つかった設定だけが使用されます。
これを利用すると、たとえば、システム管理者が /etc/bioinformatics/ に置いた
設定のうち個人的に変更したいものだけ ~/.bioinformatics/ で上書きすることが
できます。サンプルの seqdatabase.ini ファイルが bioruby のソースに含まれて
いますので参照してください。

設定ファイルの中身は stanza フォーマットと呼ばれる書式で記述します。

    [データベース名]
    protocol=プロトコル名
    location=サーバ名

このようなエントリを各データベースについて記述することになります。
データベース名は、自分が使用するためのラベルなので分かりやすいものを
つければ良く、実際のデータベースの名前と異なっていても構わないようです。
同じ名前のデータベースが複数あるときは最初に書かれているものから順に
接続を試すように仕様書では提案されていますが、今のところ BioRuby では
それには対応していません。

また、プロトコルの種類によっては location 以外にも（MySQL のユーザ名など）
追加のオプションを記述する必要があります。現在のところ、仕様書で規定され
ている protocol としては以下のものがあります。

  * index-flat
  * index-berkeleydb
  * biofetch
  * biosql
  * bsane-corba
  * xembl

今のところ BioRuby で使用可能なのは index-flat, index-berkleydb, biofetch
と biosql だけです。また、BioRegistryや各プロトコルの仕様は変更されること
がありますが、BioRubyはそれに追従できていないかもしれません。

BioRegistry を使うには、まず Bio::Registryオブジェクトを作成します。
すると、設定ファイルが読み込まれます。

    reg = Bio::Registry.new
    
    # 設定ファイルに書いたデータベース名でサーバへ接続
    serv = reg.get_database('genbank')
    
    # ID を指定してエントリを取得
    entry = serv.get_by_id('AA2CG')

ここで serv は設定ファイルの [genbank] の欄で指定した protocol プロトコ
ルに対応するサーバオブジェクトで、Bio::SQL や Bio::Fetch などのインスタ
ンスが返っているはずです（データベース名が見つからなかった場合は nil）。

あとは OBDA 共通のエントリ取得メソッド get_by_id を呼んだり、サーバオ
ブジェクト毎に固有のメソッドを呼ぶことになりますので、以下の BioFetch や
BioSQL の解説を参照してください。


== BioFlat

BioFlat はフラットファイルに対してインデックスを作成し、エントリを高速に
取り出す仕組みです。インデックスの種類は、RUbyの拡張ライブラリに依存しない
index-flat と Berkeley DB (bdb) を使った index-berkeleydb の2種類が存在
します。なお、index-berkeleydb を使用するには、BDB という Ruby の拡張
ライブラリを別途インストールする必要があります。インデックスの作成には
bioruby パッケージに付属する br_bioflat.rb コマンドを使って、

    % br_bioflat.rb --makeindex データベース名 [--format クラス名] ファイル名

のようにします。BioRubyはデータフォーマットの自動認識機能を搭載している
ので --format オプションは省略可能ですが、万一うまく認識しなかった場合は
BioRuby の各データベースのクラス名を指定してください。検索は、

    % bioflat データベース名 エントリID

とします。具体的に GenBank の gbbct*.seq ファイルにインデックスを作成し
て検索する場合、

    % bioflat --makeindex my_bctdb --format GenBank gbbct*.seq
    % bioflat my_bctdb A16STM262

のような感じになります。

Ruby の bdb 拡張モジュール(詳細は http://raa.ruby-lang.org/project/bdb/ 参照)
がインストールされている場合は Berkeley DB を利用してインデックスを作成する
ことができます。この場合、

    % bioflat --makeindex-bdb データベース名 [--format クラス名] ファイル名

のように "--makeindex" のかわりに "--makeindex-bdb" を指定します。


== BioFetch

BioFetch は CGI を経由してサーバからデータベースのエントリを取得する仕様
で、サーバが受け取る CGI のオプション名、エラーコードなどが決められてい
ます。クライアントは HTTP を使ってデータベース、ID、フォーマットなどを指
定し、エントリを取得します。

BioRuby プロジェクトでは GenomeNet の DBGET システムをバックエンドとした
BioFetch サーバを実装しており、bioruby.org で運用しています。このサーバの
ソースコードは BioRuby の sample/ ディレクトリに入っています。現在のところ
BioFetch サーバはこの bioruby.org のものと EBI の二か所しかありません。

BioFetch を使ってエントリを取得するには、いくつかの方法があります。

(1) ウェブブラウザから検索する方法（以下のページを開く）

      http://bioruby.org/cgi-bin/biofetch.rb

(2) BioRuby付属の br_biofetch.rb コマンドを用いる方法

      % br_biofetch.rb db_name entry_id

(3) スクリプトの中から Bio::Fetch クラスを直接使う方法

      serv = Bio::Fetch.new(server_url)
      entry = serv.fetch(db_name, entry_id)

(4) スクリプトの中で BioRegistry 経由で Bio::Fetch クラスを間接的に使う方法

      reg = Bio::Registry.new
      serv = reg.get_database('genbank')
      entry = serv.get_by_id('AA2CG')

もし(4) を使いたい場合は seqdatabase.ini で

    [genbank]
    protocol=biofetch
    location=http://bioruby.org/cgi-bin/biofetch.rb
    biodbname=genbank

などと指定しておく必要があります。

=== BioFetch と Bio::KEGG::GENES, Bio::AAindex1 を組み合わせた例

次のプログラムは、BioFetch を使って KEGG の GENES データベースから古細菌
Halobacterium のバクテリアロドプシン遺伝子 (VNG1467G) を取ってきて、同じ
ようにアミノ酸指標データベースである AAindex から取得したαヘリックスの
指標 (BURA740101) を使って、幅 15 残基のウィンドウサーチをする例です。

    #!/usr/bin/env ruby
    
    require 'bio'

    entry = Bio::Fetch.query('hal', 'VNG1467G')
    aaseq = Bio::KEGG::GENES.new(entry).aaseq
    
    entry = Bio::Fetch.query('aax1', 'BURA740101')
    helix = Bio::AAindex1.new(entry).index
    
    position = 1
    win_size = 15
    
    aaseq.window_search(win_size) do |subseq|
      score = subseq.total(helix)
      puts [ position, score ].join("\t")
      position += 1
    end

ここで使っているクラスメソッド Bio::Fetch.query は暗黙に bioruby.org の
BioFetch サーバを使う専用のショートカットです。（このサーバは内部的には
ゲノムネットからデータを取得しています。KEGG/GENES データベースの hal や 
AAindex データベース aax1 のエントリは、他の BioFetch サーバでは取得でき
ないこともあって、あえて query メソッドを使っています。）

== BioSQL

to be written...

== BioRuby のサンプルプログラムの使い方

BioRuby のパッケージには samples/ ディレクトリ以下にいくつかのサンプルプ
ログラムが含まれています。古いものも混じっていますし、量もとても十分とは
言えないので、実用的で面白いサンプルの提供は歓迎です。

to be written...

== さらなる情報

他のチュートリアル的なドキュメントとしては、BioRuby Wikiに置いてある
BioRuby in Anger があります。

=end

